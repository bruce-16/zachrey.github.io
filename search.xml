<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[转载：JS运行机制解析]]></title>
    <url>%2F%E8%BD%AC%E8%BD%BD%EF%BC%9AJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[原文地址这里只是截取了原文的一部分，有兴趣的全面了解的，建议去看原文。 浏览器多进程，JS单线程，JS事件循环机制，三个概念进程和线程的区别一个形象的比喻：123456789- 进程是一个工厂，工厂有它的独立资源- 工厂之间相互独立- 线程是工厂中的工人，多个工人协作完成任务- 工厂内有一个或多个工人- 工人之间共享空间 进一步再完善完善概念：123456789- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 在windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。 这里可以得出这样的结论：进程是cpu资源分配的最小单位（系统会给它分配内存） 再用较为官方的术语描述一遍： 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） tips 不同进程之间也可以通信，不过代价较大 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行） 浏览器是多进程的理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解） 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 再来看看系统的任务管理器和chrome管理器展示： 图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上（不过，某些版本的ie却是单进程的） 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器都包含哪些进程？知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程） Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有： 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为： 页面渲染，脚本执行，事件处理等 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 浏览器多进程的优势相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。 当然，内存等资源消耗也会更大，有点空间换时间的意思。 重点是浏览器内核（渲染进程）重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程 页面的渲染，js的执行，事件的循环等都在这个进程内进行。 请牢记，浏览器的渲染进程是多线程的 看看它都包含了哪些线程（一些主要的常驻线程）： GUI渲染线程 负责渲染浏览器界面，解析HTML、css、构建DOM树和RenderObject树、布局和绘制等。 当界面需要重绘（Repaint）或者由于某种操作引发的回流（reflow）时，该线程就会执行。 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程就会被挂起（相当于被冻结），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行js程序。 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 时事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开一个线程协助） 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在的线程。 浏览器定时器并不是有Javascript引擎技术的，（因为Javascript引起是单线程的，如果处于阻塞线程就会影响计时的准确） 因此通过单线程计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由javascript引起执行。 Browser进程和浏览器内核（Renderer进程）的通信过程打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程： Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来 梳理浏览器内核中线程之间的关系到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念 GUI渲染线程与JS引擎线程互斥由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。MDN的官方解释是：1234567Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 WebWorker与SharedWorker既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程补充下浏览器的渲染流程（简单版本）12345- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程- 浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了 既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。 这里重绘参考来源中的一张图：（参考来源第一篇） load事件与DOMContentLoaded事件的先后上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？ 很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）所以，顺序是：DOMContentLoaded -&gt; load css加载是否会阻塞dom树渲染？这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 从Event Loop谈JS的运行机制到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。 注意，这里不谈可执行上下文，VO，scop chain等概念（这些完全可以整理成另一篇文章了），这里主要是结合Event Loop来谈JS代码是如何执行的。 读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习） JS引擎线程 事件触发线程 定时触发器线程 然后再理解一个概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。 事件循环机制进一步补充这里就直接引用一张图片来协助理解： 上图大致描述就是： 主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 单独说说定时器上述事件循环机制的核心是：JS引擎线程和事件触发线程 但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 譬如: 123setTimeout(function()&#123; console.log(&apos;hello!&apos;);&#125;, 1000); 这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行 12345setTimeout(function()&#123; console.log(&apos;hello!&apos;);&#125;, 0);console.log(&apos;begin&apos;); 这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定) 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列） setTimeout而不是setInterval用setTimeout模拟定期计时和直接用setInterval是有区别的。 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的， 如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调， 如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误 （这一块后续有补充，setInterval自带的优化，不会重复添加回调） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。 事件循环进阶：macrotask与microtask这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下）， 强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：12345678910111213console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 嗯哼，它的正确执行顺序是这样子的：12345script startscript endpromise1promise2setTimeout 为什么呢？因为Promise里有了一个一个新的概念：microtask 或者，进一步，JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务 也就是说，在当前task任务后，下一个task之前，在渲染之前 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别很么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 另外，setImmediate则是规定：在下一次Event Loop（宏任务）时触发（所以它是属于优先级较高的宏任务）， （Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面）， 所以setImmediate如果嵌套的话，是需要经过多个Loop才能完成的， 而不会像process.nextTick一样没完没了。 参考：https://segmentfault.com/q/1010000011914016 再根据线程来理解下： macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 （这点由自己理解+推测得出，因为它是在主线程下无缝执行的） 所以，总结下运行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 另外，请注意下Promise的polyfill与官方版本的区别： 官方版本中，是标准的microtask形式 polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式 请特别注意这两点区别 注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Event</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载：深入浏览器事件]]></title>
    <url>%2F%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6.html</url>
    <content type="text"><![CDATA[转载： https://zhuanlan.zhihu.com/p/45111890作者： 小蘑菇小哥 翻译和整理自 Google Developer Day China 2018 by Jake Archibald, 2018.9.21。个人认为是整个 GDD WEB 方面最有技术含量的讲座。 另外：本文的内容是浏览器的事件循环，并不是 nodejs 的事件循环，不要将两者混淆。 我们先从一段代码开始 12document.body.appendChild(el)el.style.display = 'none' 这两句代码先把一个元素添加到 body，然后隐藏它。从直观上来理解，可能大部分人觉得如此操作会导致页面闪动，因此编码时经常会交换两句的顺序：先隐藏再添加。 但实际上两种写法都不会造成闪动，因为他们都是同步代码。浏览器会把同步代码捆绑在一起执行，然后以执行结果为当前状态进行渲染。因此无论两句是什么顺序，浏览器都会执行完成后再一起渲染，因此结果是相同的。（除非同步代码中有获取当前计算样式的代码，后面会提到） 从本质上看，JS 是单进程的，也就是一次只能执行一个任务（或者说方法）。与之相对人不是单进程的，我们可以一边动手一边动脚；一边跑步一边说话，因此我们很难体会“阻塞”的概念。在 JS 中，阻塞值得就是因为某个任务（方法）执行时间太长，导致其他任务难以被执行的情况。 异步队列但事实上有些任务的确是需要等待一会儿再处理的，例如 setTimeout，或者异步请求等。因此把主进程卡住等待返回会严重影响效率和体验，所以 JS 还增加了异步队列 (task queue) 来解决这个问题。 每次碰到异步操作，就把操作添加到异步队列中。等待主进程为空（即没有同步代码需要执行了），就去执行异步队列。执行完成后再回到主进程。 以 setTimeout(callback， ms) 为例： 初始状态：异步开关关闭（因为异步队列为空）。然后 ms 毫秒后添加一个任务 T 到队列中 现在异步队列不为空了，异步开关打开，然后主进程（白色方块）进入到异步队列，准备去执行黄色的 timeout 任务。 渲染过程页面并不是时时刻刻被渲染的，浏览器会有固定的节奏去渲染页面，称为 render steps。它内部分为 3 个小步骤，分别是 Structure - 构建 DOM 树的结构 Layout - 确认每个 DOM 的大致位置（排版） Paint - 绘制每个 DOM 具体的内容（绘制） 我们考虑如下的代码： 123button.addEventListener('click', () =&gt; &#123; while(true);&#125;) 点击后会导致异步队列永远执行，因此不单单主进程，渲染过程也同样被阻塞而无法执行，因此页面无法再选中（因为选中时页面表现有所变化，文字有背景色，鼠标也变成 text），也无法再更换内容。（但鼠标却可以动！） 如果我们把代码改成这样 1234function loop() &#123; setTimeout(loop, 0)&#125;loop() 每个异步任务的执行效果都是加入一个新的异步任务，新的异步任务将在下一次被执行，因此就不会存在阻塞。主进程和渲染过程都能正常进行。 requestAnimationFrame是一个特别的异步任务，只是注册的方法不加入异步队列，而是加入渲染这一边的队列中，它在渲染的三个步骤之前被执行。通常用来处理渲染相关的工作。 我们来看一下 setTimeout 和 requestAnimationFrame 的差别。假设我们有一个元素 box，并且有一个 moveBoxForwardOnePixel 方法，作用是让这个元素向右移动 1 像素。 12345678910111213// 方法 1function callback() &#123; moveBoxForwardOnePixel(); requestAnimationFrame(callback)&#125;callback()// 方法 2function callback() &#123; moveBoxForwardOnePixel(); setTimeout(callback, 0)&#125;callback() 有这样两种方法来让 box 移动起来。但实际测试发现，使用 setTimeout 移动的 box 要比 requestAnimationFrame 速度快得多。这表明单位时间内 callback 被调用的次数是不一样的。 这是因为 setTimeout 在每次运行结束时都把自己添加到异步队列。等渲染过程的时候（不是每次执行异步队列都会进到渲染循环）异步队列已经运行过很多次了，所以渲染部分会一下会更新很多像素，而不是 1 像素。requestAnimationFrame 只在渲染过程之前运行，因此严格遵守“执行一次渲染一次”，所以一次只移动 1 像素，是我们预期的方式。 如果在低端环境兼容，常规也会写作 setTimeout(callback, 1000 / 60) 来大致模拟 60 fps 的情况，但本质上 setTimeout 并不适合用来处理渲染相关的工作。因此和渲染动画相关的，多用 requestAnimationFrame，不会有掉帧的问题（即某一帧没有渲染，下一帧把两次的结果一起渲染了） 同步代码的合并开头说过，一段同步代码修改同一个元素的属性，浏览器会直接优化到最后一个。例如 123box.style.display = 'none'box.style.display = 'block'box.style.display = 'none' 浏览器会直接隐藏元素，相当于只运行了最后一句。这是一种优化策略。 但有时候也会给我们造成困扰。例如如下代码： 123box.style.transform = 'translateX(1000px)'box.style.tranition = 'transform 1s ease'box.style.transform = 'translateX(500px)' 我们的本意是从让 box 元素的位置从 0 一下子 移动到 1000，然后 动画移动 到 500。 但实际情况是从 0 动画移动 到 500。这也是由于浏览器的合并优化造成的。第一句设置位置到 1000 的代码被忽略了。 解决方法有 2 个： 1. 我们刚才提过的 requestAnimationFrame。思路是让设置 box 的初始位置（第一句代码）在同步代码执行；让设置 box 的动画效果（第二句代码）和设置 box 的重点位置（第三句代码）放到下一帧执行。 但要注意，requestAnimationFrame 是在渲染过程 之前 执行的，因此直接写成 12345box.style.transform = 'translateX(1000px)'requestAnimationFrame(() =&gt; &#123; box.style.tranition = 'transform 1s ease' box.style.transform = 'translateX(500px)'&#125;) 是无效的，因为这样这三句代码依然是在同一帧中出现。那如何让后两句代码放到下一帧呢？这时候我们想到一句话：没有什么问题是一个 requestAnimationFrame 解决不了的，如果有，那就用两个： 1234567box.style.transform = 'translateX(1000px)'requestAnimationFrame(() =&gt; &#123; requestAnimationFrame(() =&gt; &#123; box.style.tranition = 'transform 1s ease' box.style.transform = 'translateX(500px)' &#125;)&#125;) 在渲染过程之前，再一次注册 requestAnimationFrame，这就能够让后两句代码放到下一帧去执行了，问题解决。（当然代码丑了点） 2. 你之所以没有在平时的代码中看到这样奇葩的嵌套用法，是因为还有更简单的实现方式，并且同样能够解决问题。这个问题的根源在于浏览器的合并优化，那么打断它的优化，就能解决问题。 1234box.style.transform = 'translateX(1000px)'getComputedStyle(box) // 伪代码，只要获取一下当前的计算样式即可box.style.tranition = 'transform 1s ease'box.style.transform = 'translateX(500px)' Microtasks现在我们要引入“第三个”异步队列，叫做 microtasks。 Microtasks are usually scheduled for things that should happen straight after the currently executing script, such as reacting to a batch of actions, or to make something async without taking the penalty of a whole new task. 简单来说, Microtasks 就是在 当次 事件循环的 结尾 立刻执行 的任务。Promise.then() 内部的代码就属于 microtasks。相对而言，之前的异步队列 (Task queue) 就叫做 macrotasks，不过一般还是简称为 tasks。 1234function callback() &#123; Promise.resolve().then(callback)&#125;callback() 这段代码是在执行 microtasks 的时候，又把自己添加到了 microtasks 中，看上去是和那个 setTimeout 内部继续 setTimeout 类似。但实际效果却和第一段 addEventListener 内部 while(true) 一样，是会阻塞主进程的。这和 microtasks 内部的执行机制有关。 我们现在已经有了 3 个异步队列了，它们是 Tasks (in setTimeout) Animation callbacks (in requestAnimationFrame) Microtasks (in Promise.then) 他们的执行特点是： Tasks 只执行一个。执行完了就进入主进程，主进程可能决定进入其他两个异步队列，也可能自己执行到空了再回来。 补充：对于“只执行一个”的理解，可以考虑设置 2 个相同时间的 timeout，两个并不会一起执行，而依然是分批的。 Animation callbacks 执行队列里的全部任务，但如果任务本身又新增 Animation callback 就不会当场执行了，因为那是下一个循环 补充：同 Tasks，可以考虑连续调用两句 requestAnimationFrame，它们会在同一次事件循环内执行，有别于 Tasks Microtasks 直接执行到空队列才继续。因此如果任务本身又新增 Microtasks，也会一直执行下去。所以上面的例子才会产生阻塞。 一段神奇的代码这是本次讲座的高光部分 考虑如下的代码： 123456789button.addEventListener('click', () =&gt; &#123; Promise.resolve().then(() =&gt; console.log('microtask 1')) console.log('listener 1')&#125;)button.addEventListener('click', () =&gt; &#123; Promise.resolve().then(() =&gt; console.log('microtask 2')) console.log('listener 2')&#125;) 在浏览器上运行后点击按钮，会按顺序打印 1234listener 1microtask 1listener 2microtask 2 但如果在上面代码的最后加上 button.click() 打印顺序会 有所区别：（你也可以自己试试看） 1234listener 1listener 2microtask 1microtask 2 主要是 listener 2 和 microtask 1 次序的问题，原因如下： 用户直接点击的时候，浏览器先后触发 2 个 listener。第一个 listener 触发完成 (listener 1) 之后，队列空了，就先打印了 microtask 1。然后再执行下一个 listener。重点在于浏览器并不实现知道有几个 listener，因此它发现一个执行一个，执行完了再看后面还有没有。 而使用 button.click() 时，浏览器的内部实现是把 2 个 listener 都同步执行。因此 listener 1 之后，执行队列还没空，还要继续执行 “listener 2” 之后才行。所以 listener 2 会早于 microtask 1。重点在于浏览器的内部实现，click 方法会先采集有哪些 listener，再依次触发。 这个差别最大的应用在于自动化测试脚本。在这里可以看出，使用自动化脚本测试和真正的用户操作还是有细微的差别。如果代码中有类似的情况，要格外注意了。 另外演讲之后我额外追问了是不是只有 Chrome 才这样表现，其他浏览器如何表现呢？于是 Jake 翻出了一篇 2015 年他自己的博客，其中设计的 case 更加完整。但当时各种浏览器给出了不一样的输出结果，因此他还在博客中分析了一波谁对谁错。但他本人的说法，现在 2018 年，虽然并不是标准，但所有浏览器都以相同的方式返回了。这也侧面印证了当时只有 Chrome 是正确的。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>Event</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几行代码创建一个静态服务.md]]></title>
    <url>%2F%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[静态服务器使用go语言创建一个静态服务只需要几行代码，这里顺便做成一个命令行的客户端吧。使用flag和http标准包，就可以简单的构成了，如下： flag导入flag包,1import "flag" 这里简单的讲解一下flag包的使用：Go语言通过使用标准库里的flag包来处理命令行参数。标准库文档 简单的使用方式： 通过flag.String(), Bool(), Int()等方式来定义命令行中需要使用的flag。或者使用例如flag.IntVar()函数，传入变量地址，将获取的值放入变量中。 在定义完flag后，通过调用flag.Parse()来进行对命令行参数的解析。 命令行参数的格式可以是： -flag xxx （使用空格，一个 - 符号） –flag xxx （使用空格，两个 - 符号） -flag=xxx （使用等号，一个 - 符号） –flag=xxx （使用等号，两个 - 符号） 这些形式里面，使用布尔类型的参数，为了防止解析时的二义性，应该使用等号的方式指定。 对于该工具，这里接收一个参数，用来指定服务的监听端口。代码如下：1234567891011121314151617package mainimport ( "flag")var ( port int)func init() &#123; flag.IntVar(&amp;port, "p", 8080, "文件服务的端口号") // 不传默认 8080&#125;func main() &#123; flag.Parse()&#125; 使用http包使用http包FileServer方法，FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：1http.Handle("/", http.FileServer(http.Dir("/tmp"))) 启动一个静态文件服务示例：1log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc")))) 两者结合，最后的代码1234567891011121314151617181920212223242526272829303132package mainimport ( "flag" "fmt" "log" "net/http" "os")var ( port int)func init() &#123; flag.IntVar(&amp;port, "p", 8080, "文件服务的端口号")&#125;func main() &#123; flag.Parse() execPath, err := os.Getwd() // 默认启动的路径为，命令执行的路径 if err != nil &#123; log.Fatal("Error: ", err) &#125; fmt.Println("path: ", execPath) http.Handle("/", http.FileServer(http.Dir(execPath))) fmt.Println("file server is running at port : ", port) err = http.ListenAndServe(fmt.Sprintf(":%d", port), nil) if err != nil &#123; log.Fatal("Error: ", err) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载：Go语言参数传递是传值还是传引用]]></title>
    <url>%2F%E8%BD%AC%E8%BD%BD%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%98%AF%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8.html</url>
    <content type="text"><![CDATA[转载，感谢作者 飞雪无情 的分享原文地址： http://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html 对于了解一门语言来说，会关心我们在函数调用的时候，参数到底是传的值，还是引用？ 其实对于传值和传引用，是一个比较古老的话题，做研发的都有这个概念，但是可能不是非常清楚。对于我们做Go语言开发的来说，也想知道到底是什么传递。 那么我们先来看看什么是值传递，什么是引用传递。 什么是传值（值传递）传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。 对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。 123456789101112func main() &#123; i:=10 ip:=&amp;i fmt.Printf("原始指针的内存地址是：%p\n",&amp;ip) modify(ip) fmt.Println("int值被修改了，新值为:",i)&#125; func modify(ip *int)&#123; fmt.Printf("函数里接收到的指针的内存地址是：%p\n",&amp;ip) *ip=1 &#125; 我们运行，可以看到输入结果如下： 123原始指针的内存地址是：0xc42000c028函数里接收到的指针的内存地址是：0xc42000c038int值被修改了，新值为: 1 首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。 所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。 通过上面的图，可以更好的理解。 首先我们看到，我们声明了一个变量i,值为10,它的内存存放地址是0xc420018070,通过这个内存地址，我们可以找到变量i,这个内存地址也就是变量i的指针ip。 指针ip也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是0xc42000c028。 在我们传递指针变量ip给modify函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量ip，它的内存地址已经变了，是新的0xc42000c038。 不管是0xc42000c028还是0xc42000c038，我们都可以称之为指针的指针，他们指向同一个指针0xc420018070，这个0xc420018070又指向变量i,这也就是为什么我们可以修改变量i的值。 什么是传引用(引用传递)Go语言(Golang)是没有引用传递的，这里我不能使用Go举例子，但是可以通过说明描述。 以上面的例子为例，如果在modify函数里打印出来的内存地址是不变的，也是0xc42000c028，那么就是引用传递。 迷惑Map了解清楚了传值和传引用，但是对于Map类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。 123456789101112131415func main() &#123; persons:=make(map[string]int) persons["张三"]=19 mp:=&amp;persons fmt.Printf("原始map的内存地址是：%p\n",mp) modify(persons) fmt.Println("map值被修改了，新值为:",persons)&#125; func modify(p map[string]int)&#123; fmt.Printf("函数里接收到map的内存地址是：%p\n",&amp;p) p["张三"]=20 &#125; 运行打印输出： 123原始map的内存地址是：0xc42000c028函数里接收到map的内存地址是：0xc42000c038map值被修改了，新值为: map[张三:20] 两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改Map的内容呢？先不急，我们先看一个自己实现的struct。 123456789101112131415func main() &#123; p:=Person&#123;"张三"&#125; fmt.Printf("原始Person的内存地址是：%p\n",&amp;p) modify(p) fmt.Println(p)&#125;type Person struct &#123; Name string&#125; func modify(p Person) &#123; fmt.Printf("函数里接收到Person的内存地址是：%p\n",&amp;p) p.Name = "李四" &#125; 运行打印输出： 123原始Person的内存地址是：0xc4200721b0函数里接收到Person的内存地址是：0xc4200721c0&#123;张三&#125; 我们发现，我们自己定义的Person类型，在函数传参的时候也是值传递，但是它的值(Name字段)并没有被修改，我们想改成李四，发现最后的结果还是张三。 这也就是说，map类型和我们自己定义的struct类型是不一样的。我们尝试把modify函数的接收参数改为Person的指针。 12345678910111213func main() &#123; p:=Person&#123;"张三"&#125; modify(&amp;p) fmt.Println(p)&#125;type Person struct &#123; Name string&#125; func modify(p *Person) &#123; p.Name = "李四" &#125; 在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面int类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用make函数创建的map是不是一个指针类型呢？看一下源代码: 12345678// makemap implements a Go map creation make(map[k]v, hint)// If the compiler has determined that the map or the first bucket// can be created on the stack, h and/or bucket may be non-nil.// If h != nil, the map can be created directly in h.// If bucket != nil, bucket can be used as the first bucket.func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap &#123; //省略无关代码&#125; 通过查看src/runtime/hashmap.go源代码发现，的确和我们猜测的一样，make函数返回的是一个hmap类型的指针*hmap。也就是说map===*hmap。 现在看func modify(p map)这样的函数，其实就等于func modify(p *hmap)，和我们前面第一节什么是值传递里举的func modify(ip *int)的例子一样，可以参考分析。 所以在这里，Go语言通过make函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的map可以理解为引用类型，但是记住引用类型不是传引用。 chan类型chan类型本质上和map类型是一样的，这里不做过多的介绍，参考下源代码: 123func makechan(t *chantype, size int64) *hchan &#123; //省略无关代码&#125; chan也是一个引用类型，和map相差无几，make返回的是一个*hchan。 和map、chan都不一样的sliceslice和map、chan都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。 1234567891011func main() &#123; ages:=[]int&#123;6,6,6&#125; fmt.Printf("原始slice的内存地址是%p\n",ages) modify(ages) fmt.Println(ages)&#125;func modify(ages []int)&#123; fmt.Printf("函数里接收到slice的内存地址是%p\n",ages) ages[0]=1&#125; 运行打印结果，发现的确是被修改了，而且我们这里打印slice的内存地址是可以直接通过%p打印的,不用使用&amp;取地址符转换。 这就可以证明make的slice也是一个指针了吗？不一定，也可能fmt.Printf把slice特殊处理了。 1234567891011func (p *pp) fmtPointer(value reflect.Value, verb rune) &#123; var u uintptr switch value.Kind() &#123; case reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer: u = value.Pointer() default: p.badVerb(verb) return &#125; //省略部分代码&#125; 通过源代码发现，对于chan、map、slice等被当成指针处理，通过value.Pointer()获取对应的值的指针。 123456789101112// If v's Kind is Slice, the returned pointer is to the first// element of the slice. If the slice is nil the returned value// is 0. If the slice is empty but non-nil the return value is non-zero.func (v Value) Pointer() uintptr &#123; // TODO: deprecate k := v.kind() switch k &#123; //省略无关代码 case Slice: return (*SliceHeader)(v.ptr).Data &#125;&#125; 很明显了，当是slice类型的时候，返回是slice这个结构体里，字段Data第一个元素的地址。 1234567891011type SliceHeader struct &#123; Data uintptr Len int Cap int&#125;type slice struct &#123; array unsafe.Pointer len int cap int&#125; 所以我们通过%p打印的slice变量ages的地址其实就是内部存储数组元素的地址，slice是一种结构体+元素指针的混合类型，通过元素array(Data)的指针，可以达到修改slice里存储元素的目的。 所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。 单纯的从slice这个结构体看，我们可以通过modify修改存储元素的内容，但是永远修改不了len和cap，因为他们只是一个拷贝，如果要修改，那就要传递*slice作为参数才可以。 123456789101112131415161718192021func main() &#123; i:=19 p:=Person&#123;name:"张三",age:&amp;i&#125; fmt.Println(p) modify(p) fmt.Println(p)&#125;type Person struct &#123; name string age *int&#125;func (p Person) String() string&#123; return "姓名为：" + p.name + ",年龄为："+ strconv.Itoa(*p.age)&#125;func modify(p Person)&#123; p.name = "李四" *p.age = 20&#125; 运行打印输出结果为： 12姓名为：张三,年龄为：19姓名为：张三,年龄为：20 通过这个Person和slice对比，就更好理解了，Person的name字段就类似于slice的len和cap字段，age字段类似于array字段。在传参为非指针类型的情况下，只能修改age字段，name字段无法修改。要修改name字段，就要把传参改为指针，比如： 12345modify(&amp;p)func modify(p *Person)&#123; p.name = "李四" *p.age = 20&#125; 这样name和age字段双双都被修改了。 所以slice类型也是引用类型。 小结最终我们可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。 是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。 这里也要记住，引用类型和传引用是两个概念。 再记住，Go里只有传值（值传递）。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用go搭建个人博客（四）：cmd工具上传文件]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8go%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Acmd%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[上一篇文章介绍结合数据库书写了处理上传文件的接口，将md文件接收并解析存放到了数据库，那么这一篇就来介绍怎么书写cmd命令行工具，上传文件。 创建命令行工具 之前的文章有介绍过，创建命令行工具就直接使用github.com/urfave/cli这个库了，它能比较方便的设置命令参数和说明，配置文档。 首先在cmd目录下创建main.go：cmd/main.go 1234567package mainimport ( ... "github.com/urfave/cli") 创建main函数，使用cli初始化命令行工具: 12345678910111213141516171819202122232425262728293031323334// 创建App实例app := cli.NewApp()// 这个应用的名称app.Name = "bpost"// 使用介绍app.Usage = "Managing blog posts"// 版本app.Version = "0.0.1"var filePath stringvar fileName stringvar host string// 设置命令行可以识别的参数 例如 bpost --upload ...app.Flags = []cli.Flag&#123; cli.StringFlag&#123; // 名称， --upload 或者 --up Name: "upload,up", // 使用说明 Usage: "Upload an article by that `file path`", // 获取的值得存放位置， bpost --upload abc.txt 这里的 abc.txt 就会存放到filePath变量中 Destination: &amp;filePath, &#125;, cli.StringFlag&#123; Name: "remove,rm", Usage: "Remove the article by that `file name`", Destination: &amp;fileName, &#125;, cli.StringFlag&#123; Name: "config,cf", Usage: "Config http request `host`", Destination: &amp;host, &#125;,&#125; 简单的初始化程序后，我们运行看看，这个工具长什么样子。在项目cmd目录下，执行go run main.go --help，当然你也是可以go build main.go或者go install main.go去打包成二进制文件，直接执行的，这里为了方便开发调试，就直接run了。可以看到命令行输出的信息为： 可以看到一个简单的命令行工具已经成形，之后就是书写处理逻辑了，上传文件等。 上传文件 上传文件会需要去请求接口，处理上传文件的接口上一篇文章已经写好了，我们这里就不多说了，有兴趣的可以看一下上一篇文章介绍的实现。 接着在mian.go中处理命令行工具的响应处理方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243func main() &#123; ... ... // 默认请求设置为本地的8888端口 var url = "http://localhost:8888" // 查看是否存在配置文件，这里的配置文件很简单，里面只是存了一个请求地址的域，没有使用很麻烦的配置，这里推荐可以使用yaml的格式文件存储，并使用读取配置文件的库"github.com/spf13/viper"，来进行读取。 isexists := exists("./url.config") if isexists &#123; file, rdRrr := ioutil.ReadFile("./url.config") if rdRrr != nil &#123; log.Fatalln("[ERROR] ", rdRrr) &#125; // 有配置文件的话，就修改url的值 url = string(file) &#125; // 命令行App执行后的响应方法 app.Action = func(c *cli.Context) error &#123; if filePath != "" &#123; upload(filePath, url) &#125; if fileName != "" &#123; remove(fileName, url) &#125; if host != "" &#123; config(host) &#125; return nil &#125; err := app.Run(os.Args) checkErr(err)&#125;func upload(filePath, url string) &#123; ...&#125;func remove(fileName, url string) &#123; ...&#125;func config(host string) &#123; ...&#125; 上面已经把命令参数对应的响应方法已经处理完毕了，接下来只需要将upload函数完善，那么这个命令行工具就可以上传文件了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func upload(filePath, url string) &#123; _, err := os.Stat(filePath) //os.Stat获取文件信息 if err != nil &#123; if os.IsExist(err) == false &#123; log.Fatalf("%s 路径不存在", filePath) &#125; &#125; // 创建表单文件 // CreateFormFile 用来创建表单，第一个参数是字段名，第二个参数是文件名 buf := new(bytes.Buffer) writer := multipart.NewWriter(buf) fileName := filepath.Base(filePath) formFile, err := writer.CreateFormFile("upload", fileName) if err != nil &#123; log.Fatalf("Create form file failed: %s\n", err) &#125; // 从文件读取数据，写入表单 srcFile, err := os.Open(filePath) if err != nil &#123; log.Fatalf("Open source file failed: %s\n", err) &#125; defer srcFile.Close() _, err = io.Copy(formFile, srcFile) if err != nil &#123; log.Fatalf("Write to form file falied: %s\n", err) &#125; // 发送表单 contentType := writer.FormDataContentType() writer.Close() // 发送之前必须调用Close()以写入结尾行 var res *http.Response res, err = http.Post(url+"/upload", contentType, buf) if err != nil &#123; log.Fatalf("Post failed: %s\n", err) &#125; defer res.Body.Close() // 判断接口返回参数，查看是否上传成功 body, _ := ioutil.ReadAll(res.Body) var dataMap map[string]interface&#123;&#125; json.Unmarshal(body, &amp;dataMap) if dataMap["status"] != 0 &#123; log.Fatalf("Post failed: %s\n", dataMap["msg"]) &#125; log.Println("[SUCCESS] Upload file is successfully. ", filePath)&#125; 上面代码主要逻辑就是，创建表单文件，然后将准备上传文件的内容读取出来写入到表单文件，然后通过http发送表单文件。 写到这里，我们就可以上传一下这个命令行工具，看是否能正常上传文件。 首先第一步： 启动服务器: 在项目根目录下，运行go run main.go。第二部： 使用cmd工具上传文件，在cmd目录下运行go run main.go --up test1.md。test1.md里面的内容需要符合上一篇介绍的md格式，不然会上传失败等。如果大家使用我的源码进行测试，那可能需要新建自己的md文件，因为我源码上的数据库里面已经测试了几个，所以再test.md上传的话，会报已经存在的反馈。 由图片可以看出，当我们上传文件的时候，服务正在执行sql进行数据库操作，当然这些信息是xorm在开发模式下才会出现的，是可以进行调整的。 最后 cmd工具肯定不只有上传文件的功，大家还可以增加需要的功能，当然，服务器上就需要想要的处理接口。我的源码中cmd工具实现了上传文件、删除文件、配置上传地址等功能，如果里面有些代码看不完全的，可以去我的github上，查看完整的源码，直接运行下。欢迎留言或者使用邮箱(zz__0123@163.com)联系我讨论，初学实践分享，有很多不足，请多多指教。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gin</tag>
        <tag>xorm</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用go搭建个人博客（三）：服务端解析md文件]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8go%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Acmd%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%92%8C%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[上一篇文章介绍了数据库的连接和路由的配置，这一篇就开始书写比较重要的功能，接收并解析md文件，然后将重要的信息存入到数据库，最后再通过一个接口将md装换成html字符串暴露出去。 处理文件上传接口 接收到一个文件后，就开始读取这个文件，将文件里面重要的信息存入数据库，为了以后能通过关键信息能遍历到指定的博客信息，然后返回给前端进行展示。 首先我们在controllers目录下创建处理上传文件的控制器： controllers/uploadFile.go : 先引入使用xorm创建的各个模板，之后使用这些将数据存入数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package controllersimport ( "crypto/md5" "errors" "fmt" ... "github.com/gin-gonic/gin" "github.com/zachrey/blog/models")const postDir = "./posts/" // 将文件方法放到一个指定的目录，如果文件过多可以放在现在各种云上面。// UpLoadFile 上传文件的控制器func UpLoadFile(c *gin.Context) &#123; // 指定数据的字段名，从该字段获取文件流 file, header, err := c.Request.FormFile("upload") // 获取上传的文件名，存储的时候使用 filename := header.Filename // 将文件名md5转一下，便于存储 md5FileName := fmt.Sprintf("%x", md5.Sum([]byte(filename))) // 获取文件名的扩展名 .md fileExt := filepath.Ext(postDir + filename) // 文件的存储路径 filePath := postDir + md5FileName + fileExt // 打印下日志 log.Println("[INFO] upload file: ", header.Filename) // 判断放文件的目录下是否已经有存在相同文件 has := hasSameNameFile(md5FileName+fileExt, postDir) if has &#123; c.JSON(http.StatusOK, gin.H&#123; "status": 1, "msg": "服务器已有相同文件名称", &#125;) return &#125; // 根据文件名的md5值，创建服务器上的文件 out, err := os.Create(filePath) if err != nil &#123; log.Fatal(err) &#125; defer out.Close() // 将信息存入数据库操作。。。。 // 将信息存入数据库操作。。。。 // 将信息存入数据库操作。。。。 // 将信息存入数据库操作。。。。 c.JSON(http.StatusOK, gin.H&#123; "status": 0, "msg": "上传成功", &#125;)&#125;func hasSameNameFile(fileName, dir string) bool &#123; files, _ := ioutil.ReadDir(dir) // 遍历目录，是否存在相同的文件，这里有两种方式来查重，可以去数据库查询是否有相同的文件名也是可以的。 for _, f := range files &#123; if fileName == f.Name() &#123; return true &#125; &#125; return false&#125; 将文件解析的信息写入数据库 一篇博客的主要信息包括：标题、分类、标签和文字字数等，这里就规定在md文件中怎么书写这些信息，以方便服务器来解析，然后存入数据库。规定md文件头几行应该书写信息，如下规定： 1234title: 标题1categories: 分类1, 分类2, 分类三label: JS, ES6--------------------------------------------- 信息内容与主体内容以---------------------------------------------进行分割。然后读取文件，往数据库写数据，还是在同一个文件中书写存入数据库的逻辑，我们来补全内容，上面留空的“存入数据库操作”就是下面的内容了。 controllers/uploadFile.go : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package controllersimport ( "crypto/md5" "errors" "fmt" ... "github.com/gin-gonic/gin" "github.com/zachrey/blog/models")...var gr sync.WaitGroupvar isShouldRemove = false// UpLoadFile 上传文件的控制器func UpLoadFile(c *gin.Context) &#123; ... // 根据文件名的md5值，创建服务器上的文件 out, err := os.Create(filePath) if err != nil &#123; log.Fatal(err) &#125; // 处理完整个上传过程后，是否需要删除创建的文件，在存在错误的情况下, 解析出错就删掉刚创建的文件。 //这个操作一定需要放在 out.close上面，因为创建的文件流，如果不关闭的话， //无法进行删除操作，又因为defer栈的执行顺序，所以必须放在上面声明。 defer func() &#123; if isShouldRemove &#123; err = os.Remove(filePath) if err != nil &#123; log.Println("[ERROR] ", err) &#125; &#125; &#125;() // 关闭文件流，存储文件。 defer out.Close() // 将上传文件的内容copy到新建的文件中，然后进行存储。 _, err = io.Copy(out, file) if err != nil &#123; log.Fatal(err) &#125; // 如果读取解析文件存在错误的话，则isShouldRemove复制为true,最后由defer进行删除 err = readMdFileInfo(filePath) if err != nil &#123; isShouldRemove = true c.JSON(http.StatusOK, gin.H&#123; "status": 1, "msg": err.Error(), &#125;) return &#125; ... // 返回json数据，请看上一段的内容&#125;// 读取文件信息，并写入数据库func readMdFileInfo(filePath string) error &#123; // 读取文件 fileread, _ := ioutil.ReadFile(filePath) // 将内容切割成每一行 lines := strings.Split(string(fileread), "\n") // 文字内容以第5行往后开始数 body := strings.Join(lines[5:], "") // 计算文字内容的文字个数 textAmount := GetStrLength(body) log.Println(lines) // 信息的标识 const ( TITLE = "title: " CATEGORIES = "categories: " LABEL = "label: " ) var ( postId int64 postCh chan int64 categoryCh chan []int64 labelCh chan []int64 ) mdInfo := make(map[string]string) /** * 并发插入三组相互不特别依赖的信息 */ for i, lens := 0, len(lines); i &lt; lens &amp;&amp; i &lt; 5; i++ &#123; // 只查找前五行 switch &#123; case strings.HasPrefix(lines[i], TITLE): mdInfo[TITLE] = strings.TrimLeft(lines[i], TITLE) postCh = make(chan int64) // 存入数据库，存入成功返回插入的记录id，放入通道postCh中 go models.InsertPost(mdInfo[TITLE], filepath.Base(filePath), int64(textAmount), postCh) case strings.HasPrefix(lines[i], CATEGORIES): mdInfo[CATEGORIES] = strings.TrimLeft(lines[i], CATEGORIES) categoryCh = make(chan []int64) // 存入数据库 go models.InsertCategory(mdInfo[CATEGORIES], categoryCh) case strings.HasPrefix(lines[i], LABEL): mdInfo[LABEL] = strings.TrimLeft(lines[i], LABEL) labelCh = make(chan []int64) // 存入数据库 go models.InsertLabel(mdInfo[LABEL], labelCh) &#125; &#125; /** * 插入相互相关的信息 */ postId = &lt;-postCh //等待文章成功插入 if postId == 0 &#123; return errors.New("服务器上已有相同文章标题") &#125; log.Println("[INFO] postId: ", postId) // 插入文章与分类的关联信息，文字与分类关联表 if categoryCh != nil &#123; go func() &#123; categoryIds := &lt;-categoryCh log.Println("[INFO] categoryIds: ", categoryIds) for _, v := range categoryIds &#123; models.InsertPostAndCategory(postId, v) &#125; &#125;() &#125; // 插入文章与标签的关联信息，文字与标签关联表 if labelCh != nil &#123; go func() &#123; labels := &lt;-labelCh log.Println("[INFO] labels: ", labels) for _, v := range labels &#123; models.InsertPostAndLabel(postId, v) &#125; &#125;() &#125; return nil // 全部成功插入，则返回没有错误，如果存在错误，则往上返回&#125;...// GetStrLength 返回输入的字符串的字数，汉字和中文标点算 1 个字数，英文和其他字符 2 个算 1 个字数，不足 1 个算 1个func GetStrLength(str string) float64 &#123; var total float64 reg := regexp.MustCompile("/·|，|。|《|》|‘|’|”|“|；|：|【|】|？|（|）|、/") for _, r := range str &#123; if unicode.Is(unicode.Scripts["Han"], r) || reg.Match([]byte(string(r))) &#123; total = total + 1 &#125; else &#123; total = total + 0.5 &#125; &#125; return math.Ceil(total)&#125; 这里使用了goroutine和通道的方法，尝试的多熟悉一下Go的特性，使用并发的去插入三组不相关的记录到数据库，然后等三组分别插入完后，串行插入相互相关的记录。 路由配置routers/router.go: 1234567891011121314151617181920package routersimport ( "log" "net/http" "github.com/gin-gonic/gin" ctrs "github.com/zachrey/blog/controllers" "github.com/zachrey/blog/models")...func loadRouters(router *gin.Engine) &#123; ... router.POST("/upload", ctrs.UpLoadFile) ...&#125; 此时我们使用postman来进行测试，启动服务，选择文件上传。 最后 怎么处理上传的md文件，是整个博客系统的重点，存好了文章数据，就可以做出各种基于这些数据的API了。下一篇文件，就来讨论下怎么实现cmd工具，上传文件。如果里面有些代码看不完全的，可以去我的github上，查看完整的源码，直接运行下。欢迎留言或者使用邮箱(zz__0123@163.com)联系我讨论，初学实践分享，有很多不足，请多多指教。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gin</tag>
        <tag>xorm</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用go搭建个人博客（二）：数据库和路由]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8go%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%B7%AF%E7%94%B1.html</url>
    <content type="text"><![CDATA[上一篇文章简单介绍了选择的技术栈和怎么初始化一个Web项目，项目目录等，这篇就来介绍路由的配置和怎么连接数据库、使用xorm。 路由配置 上一章介绍了使用gin创建一个初始的web项目。现在，我们就使用gin提供的路由机制来配置。在main.go中进行添加： main.go： 123456789101112131415161718192021222324package mainimport ( "io" "os" "github.com/gin-gonic/gin" "github.com/zachrey/blog/routers")func main() &#123; r := gin.New() // 设置日志文件 f, _ := os.Create("gin.log") gin.DefaultWriter = io.MultiWriter(f, os.Stdout) // 使用日志中间件 r.Use(gin.Logger()) // 设置静态文件夹 r.Static("/static", "./static") // 加载路由 routers.LoadRouters(r) r.Run(":8888")&#125; routers.LoadRouters函数，我们放在routers/包下面，让所有的路由都统一管理： routers/router.go： 12345678910111213141516171819202122232425262728293031323334package routersimport ( "log" "net/http" "github.com/gin-gonic/gin" // ctrs "github.com/zachrey/blog/controllers")// LoadRouters 初始化routerfunc LoadRouters(router *gin.Engine) &#123; loadRouters(router)&#125;func loadRouters(router *gin.Engine) &#123; // 这里测试根路由 /* 控制器函数会接收一个`gin.Context`类型的指针，这个指针包含http的请求和响应信息和操作方法。 */ router.GET("/", func(c *gin.Context) &#123; post := models.GetPostByID(1) log.Println("@@ post", post) // 返回一个json格式的数据 c.JSON(http.StatusOK, gin.H&#123; "Status": 0, "data": post, &#125;) &#125;) // 路由控制函数，我们全部放在controllers目录下 //router.GET("/get-posts", ctrs.GetPosts) // ...... 很多很多路由。。。&#125; ctrs.GetPosts这个控制器函数，之后结合数据库来进行演示。现在启动项目go run main.go，然后在浏览器中访问localhost:8888/来看，根路由会返回什么。 连接数据库 由于个人博客功能不是很复杂，这里就直接使用了sqlite这种轻量级的数据库。GO没有内置的数据库驱动，但是GO定义了数据库驱动包接口database/sql/driver，所以就算对于不同的数据库，可以在这些接口的基础上来开发自己的驱动包。那么，需要连接sqlite数据库，我们就需要去找sqlite的数据驱动包。 1github.com/mattn/go-sqlite3 以上就是需要用到的驱动包的地址，只需要在项目中导入初始化就行。 其他的驱动包列表：https://github.com/golang/go/wiki/SQLDrivers 在项目的入口文件main.go初始化（导入）数据库驱动: main.go： 123456789101112131415package mainimport ( "io" "os" "github.com/gin-gonic/gin" _ "github.com/mattn/go-sqlite3" // 只导入，并不需要去使用，所以注意前面的"_"下划线)func main() &#123; r := gin.New() ... r.Run(":8888")&#125; 初始化数据库后，在database目录下，创建一个数据库配置文件，我们使用xorm来连接数据库。 database/sqlite3.go： 123456789101112131415161718192021222324package databaseimport ( "log" "github.com/xormplus/xorm" // 记得 go get 获取哦)// ORM xorm引擎的实例，供其他模块可以直接使用，注意**首字母大写**，因为`Go`语音的隐藏和公开的规则，大写为公开，小写为隐藏。var ORM *xorm.Enginefunc init() &#123; // 使用init来自动连接数据库，并创建ORM实例 var err error ORM, err = xorm.NewEngine("sqlite3", "./database/test.db") if err != nil &#123; log.Fatalln(err) return &#125; err = ORM.Ping() // 测试能操作数据库 if err != nil &#123; log.Fatalln(err) return &#125; ORM.ShowSQL(true) // 测试环境，显示每次执行的sql语句长什么样子&#125; 上面的xorm操作，建议多看官方文档。我的github上有现成的测试的数据库文件，也就是这个博客系统的数据库文件，大家可以下载下来，连接试试。看会不会报错，ping操作能不能连通。这里有个注意的地方./database/test.db，这个相对路径，因为我把test.db这个文件放在sqlite3.go这个配置文件的同级目录下，如果你创建引擎的时候这样写./test.db，它并不会指向/database/test.db这个文件，而是会指向项目根目录下的/test.db，从而会创建一个新的空的/text.db文件。因为Go语言是已包来管理项目的，所以./表示的是包的同级目录，而不是包里面文件的同级目录。 创建ORM模板 所有的模板都放在models下面，每一个model都对应一张数据库的表，我们可以使用sqlite数据库连接工具来看看，test.db有哪些表和具体字段，这里就展示model了，因为字段都是对应的。 models/post.go： 1234567891011121314151617181920212223242526272829303132333435363738394041package modelsimport ( "log" db "github.com/zachrey/blog/database" // 导入之前创建的数据库引擎实例，用来操作数据库)type MPost struct &#123; Id int64 `xorm:"pk autoincr"` Title string `xorm:"'title'"` FileName string `xorm:"file_name"` TextAmount int64 `xorm:"text_amount"` CreateTime int64 `xorm:"created 'create_time'"`&#125;// GetPostByID 根据ID获取文章func GetPostByID(Id int64) *MPost &#123; var post MPost // 根据Id得到一个MPost类型的实例 has, err := db.ORM.Table("posts").Id(Id).Get(&amp;post) if err != nil &#123; log.Println("ERROR:", err) return nil &#125; if has == false &#123; return nil &#125; return &amp;post&#125;// GetPosts 获取所有的文章func GetPosts() *[]MPost &#123; var post []MPost err := db.ORM.Table("posts").Find(&amp;post) if err != nil &#123; log.Println("ERROR:", err) return nil &#125; return &amp;post&#125; 使用struct来对应数据库的表，表中字段的类型，约束等。注意结构体的属性首字母都是大写的，视情况而定，如果这个结构体需要被访问，最好全部都写错大写。关于类型的映射，可以看官网的“Go与字段类型对应表”目录，里面会有详细的说明。对于xorm:&quot;pk autoincr&quot;这样的东西，成为Tag，具体的Tag规则看官网的“Column属性定义”目录的介绍。 在控制器中使用模板上的方法控制器全部放在controllers/下。 /controllers/posts.go： 123456789101112131415161718package controllersimport ( "log" "net/http" "github.com/gin-gonic/gin" "github.com/zachrey/blog/models")//GetPosts 获取所有的文章func GetPosts(c *gin.Context) &#123; labels := models.GetPosts() // 使用在模板中书写的方法 c.JSON(http.StatusOK, gin.H&#123; "status": 0, "data": labels, &#125;)&#125; 在路由中使用控制器 routers/router.go： 12345678910111213141516171819202122232425262728293031323334package routersimport ( "log" "net/http" "github.com/gin-gonic/gin" ctrs "github.com/zachrey/blog/controllers")// LoadRouters 初始化routerfunc LoadRouters(router *gin.Engine) &#123; loadRouters(router)&#125;func loadRouters(router *gin.Engine) &#123; // 这里测试根路由 /* 控制器函数会接收一个`gin.Context`类型的指针，这个指针包含http的请求和响应信息和操作方法。 */ router.GET("/", func(c *gin.Context) &#123; post := models.GetPostByID(1) log.Println("@@ post", post) // 返回一个json格式的数据 c.JSON(http.StatusOK, gin.H&#123; "Status": 0, "data": post, &#125;) &#125;) // 路由控制函数，我们全部放在controllers目录下 router.GET("/get-posts", ctrs.GetPosts) // ...... 很多很多路由。。。&#125; 现在我们来访问localhost:8888/get-posts，查看返回的json数组。 最后 该项目示例已经写完放在github上了，这第二篇，用来介绍配置路由和使用xorm操作数据库。欢迎讨论或者留言，也可以在我的github上克隆项目直接跑着看看。之后继续更新，中间遇到的问题和一些解决办法。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gin</tag>
        <tag>xorm</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用go搭建个人博客（一）：初始化项目]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8go%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE.html</url>
    <content type="text"><![CDATA[最近学习了Go的一些基本知识之后，决定实践一下。因为个人博客是比较常见和比较简单的联系实例，所以就打算再精简一下需求，做一个比较简单的个人博客，来了解Go语言在Web服务上的基本使用。 考虑需要实现的功能 一个简化版的个人博客，满足基本需求即可。 存在一个可以用来管理md文件的工具，该工具能将本地的md文件，也就是写好的博客，能上传到服务器上，或者进行根据文章标题进行文章文件的删除等。该工具就模仿hexo博客系统做一个命令行工具吧，简单也直接。 Web前端页面：1. 存在一个主页用来显示所有的文章，这里就以一个列表的形式存在。 2. 列表每项，有文章的基本信息，例如：标题、上传时间、文章字数等。3. 文章内容页。 4. 支持进行分类和标签检索相应文章。 Web服务端： 1. 提供查询所有文章、根据分类ID查询对于文章列表、根据标签ID查询对于文章列表等API。 2. 提供将md文件转成HTML字符串的功能，最后一接口形式暴露。 3. 接收文件，并分析md文件，将相应的信息存入数据库。 大概整个系统由上面三个部分组成。 采用前前后端分离的模式 后端 ： 对于Go语言的Web框架有很多，哪怕是使用内置的net/http也能比较方便的书写Web服务，所以这里选择比较轻量、比较简单的Web框架gin； 因为数据库的业务很少，不需要存储大量的相关信息，只需要存储一个文章的标签、标题、分类和时间等，所以就直接使用轻量级的Sqlite数据库，直接以db文件形式存放； 数据库的ORM工具，国内有比较火的xorm，就直接拿来使用了，文档算是很全面的，实在不行就直接写sql也是可以的。 前端： 如今前端比较流行构建单页面应用，本人目前也是一个前端程序员，就拿自己熟悉的React来构建吧。 UI框架，选用Google的Material-ui，个人感觉还是比较漂亮的UI库。 命令行工具： 我在google上找了会，也有现成的库（cli）可以用。 初始化项目 首先我们在$GOPATH/src/github.com/[your_name]/创建一个blog文件夹，姑且就这样命名吧。无所谓~ 使用的是前后端分离的模式，我这里创建如下几个文件夹： cmd 用来开发命令行工具 controllers 用来存放后端的控制器，一些操作，一些功能。* database 存放数据库的配置和连接数据库的操作。 front_web 用来存放React项目。 models 存放使用xorm对应数据库表的模板（一些数据结构Struct） posts 由于是比较简单的系统，我就直接将客户端上传的文章放在了这个文件夹。 routers 后端接口（路由） static Web静态文件夹 main.go 整个程序的主入口。 使用gin创建一个Http服务： 使用get工具，将gin依赖安装到本地，gin文档 1go get github.com/gin-gonic/gin 在mian.go中导入gin，然后创建服务。 12345678910111213141516171819202122package mainimport ( "io" "os" "github.com/gin-gonic/gin")func main() &#123; r := gin.New() // 设置日志文件 f, _ := os.Create("gin.log") gin.DefaultWriter = io.MultiWriter(f, os.Stdout) // 使用日志中间件 r.Use(gin.Logger()) // 设置静态文件夹 r.Static("/static", "./static") r.Run(":8888")&#125; 运行该main.go文件，就可以看到启动信息，然后在浏览器中输入http://localhost:8888/就可以访问了，虽然现在什么都没有。 最后 该项目示例已经写完放在github上了，这只是第一篇，用来介绍功能和怎么样来初始化项目的。大家在留言一起讨论或者去我的github上克隆项目直接跑着看看。之后继续更新，中间遇到的问题和一些解决办法。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gin</tag>
        <tag>xorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go中的切片-1]]></title>
    <url>%2FGo%E4%B8%AD%E7%9A%84%E5%88%87%E7%89%87-1.html</url>
    <content type="text"><![CDATA[世界上没有比快乐更能使人美丽的化妆品。——布雷顿 切片的内部实现切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。 可以看到切片有三个元数据，一个是指向底层数组头部的指针、一个代表切片的长度、一个代表切片的容量。 创建切片使用make创建。123slice1 := make([]int) // nilslice2 := make([]int, 5) // &#123;0, 0, 0, 0, 0&#125; 因为int的空值为0slice3 := make([]int, 5, 10) // &#123;0, 0, 0, 0, 0&#125; 可以增长到10个元素 这里看起来slice2和slice3值的区别不大，但是当谁用append方式，容器这个元数据决定，是否新建一个底层数组，下面有具体说的地方。 容量小于长度的切片会在编译时报错 字面量创建123456789// 创建字符串切片// 其长度和容量都是 5 个元素slice := []string&#123;"Red", "Blue", "Green", "Yellow", "Pink"&#125;// 创建一个整型切片// 其长度和容量都是 3 个元素slice := []int&#123;10, 20, 30&#125;// 创建字符串切片// 使用空字符串初始化第 100 个元素slice := []string&#123;99: ""&#125; 如果在创建的时候[]写了值，例如[6]，这样创建的是数组，而不是切片 nil 和空切片因为切片也是属于指针的，所以它的空值就是nil123456var slice []int// slice == nilvar slice1 = []int&#123;&#125;// slice1 != nillen(slice1) == 0 // true 使用切片创建切片123456// 创建一个整型切片// 其长度和容量都是 5 个元素slice := []int&#123;10, 20, 30, 40, 50&#125;// 创建一个新切片// 其长度为 2 个元素，容量为 4 个元素newSlice := slice[1:3] 执行完代码清单 4-25 中的切片动作后，我们有了两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分（见图 4-12）。 使用 append 向切片增加元素123456789// 创建一个整型切片// 其长度和容量都是 5 个元素slice := []int&#123;10, 20, 30, 40, 50&#125;// 创建一个新切片// 其长度为 2 个元素，容量为 4 个元素newSlice := slice[1:3]// 使用原有的容量来分配一个新元素// 将新元素赋值为 60newSlice = append(newSlice, 60) 结果如下 注意的地方函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为1.25，也就是会每次增加 25%的容量。随着语言的演化，这种增长算法可能会有所改变。 看如下代码12345678slice := []int&#123;1, 2, 3, 4&#125;newSlice := append(slice, 5, 6) // 增加两个，因为原来slice的容器只有4，但是这里增加了2个，容量不够了，所以就自动的产生了新的底层数组，新的切片的容量变成了8。newSlice2 := append(newSlice, 6) // 这里在newSlice的基础上增加一个元素，但是没有超过newSlice的容量8，所以不会产生新的底层数组，newSlice2和newSlice使用同一个底层数组。newSlice2[0] = 10 // 观察前两个切片的值fmt.Println(newSlice2[0]) // 10fmt.Println(slice[0]) // 1fmt.Println(newSlice[0]) // 10 函数传递在函数间传递数组的时候，是复制的数组的值，如果数组过多，就会消耗过多内存，所以数组一般会使用func(arr *[]int)指针的形式传递。但是切片区别于数组，它只是一个指向数组的指针，所以就算底层数组很大，在函数传递的时候，只会复制切片（指针），不会复制底层数组，所以传输效率很高。 文中部分代码和图片来着《Go语言实战》 感谢作者]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Slice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中NAN和Infinity两个特殊值需要注意的地方]]></title>
    <url>%2FJS%E4%B8%ADNAN%E5%92%8CInfinity%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%80%BC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9.html</url>
    <content type="text"><![CDATA[每一天都以许下希望开始，以收获经验结束。 现在来讨论讨论在JS中操作数值进行计算的时候，会出现的两个特殊值：NaN 和 Infinity。 NaN在JS中，它被解释为”not a number”,一般在将一个字符串解析成数字时候出现的错误：1Number('XYZ'); // NaN NaN与所有的值都不相等，哪怕就是算与自己相比较都不相等。123NaN === NaN; // falseNaN === 1; // false... 但是请注意使用typeof计算NaN的类型的时候，它竟然返回的是number。。。1typeof NaN; // 'number' 很是无语。 怎么判断一个值是否为NaN？NaN是javascript唯一个和自身不相等的值，所以我们不能使用”==”或者”===”来判断它，我们需要使用ES6提供Number.isNaN来判断它，ES6之前有一个全局函数isNaN也可以用来判断。1Number.isNaN(NaN); // true Number.isNaN和isNaN这两个函数的表现形式是不相同的：12isNaN('xyz'); // trueNumber.isNaN('xyz'); // false 从这里看出isNaN会将参数强制转换为数值类型，然后再去判断，但是Number.isNaN不会这么做。 Number的强制转换当使用关键字Number进行类型显示转换的时候，里面究竟做了什么呢？这里简单说明下。 看如下代码： 123456789101112let obj = &#123; valueOf: function ()&#123; return 2; &#125;&#125;Number(obj); // 2obj = &#123; valueOf: function ()&#123; return NaN; &#125;&#125;const objNum = Number(obj); // NaNNumber.isNaN(obj); // falseNumber.isNaN(objNum); // trueisNaN(obj); // true 这里可以看出，当使用Number强转的时候，会去调用值原型上的方法valueOf，当我们重写这个方法后，就可以转换为指定的值，上面也清晰的解释了Number.isNaN和isNaN的区别。 Infinity当你去除以一个0时，就会得到这个特殊值。123 / 0 // InfinityInfinity / 0 // Infinity 但是请注意：1NaN / 0 // NaN NaN这个值与其他值进行操作还是为NaN。 对于Infinity你不能再与一个Infinity进行相互作用，不然就会得到NaN。12Infinity / Infinity // NaNInfinity - Infinity // NaN 但是可以做乘和加的运算12Infinity + Infinity // InfinityInfinity * Infinity // Infinity 因为这个值表象为无穷,上面四个运算就是符合数学逻辑的。 有错误或者描述不清晰的地方，欢迎指正~]]></content>
      <tags>
        <tag>JS</tag>
        <tag>类型</tag>
        <tag>js-number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么React组件点击事件回调函数会需要绑定this]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88React%E7%BB%84%E4%BB%B6%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BC%9A%E9%9C%80%E8%A6%81%E7%BB%91%E5%AE%9Athis.html</url>
    <content type="text"><![CDATA[世界上没有比快乐更能使人美丽的化妆品。——布雷顿 js里面的this绑定是代码执行的时候进行绑定的，而不是编写的时候，所以this的指向取决于函数调用时的各种条件。 关于this的几种绑定规则和分析可以参考《你不知道的javascript》上卷对this的详解。 这里简单的说明一下this的默认绑定：12345var a = "foo";function foo()&#123; console.log(this.a);&#125;foo(); // "foo" 在浏览器环境中，单独运行的函数，也就是没有跟任何对象产生关系的情况下执行该函数，此时的this会指向window对象，在Node环境中会指向global对象。所以上面代码中this指向了window，然后调用了找到了window中的变量a。 当使用严格模式后：123456var a = "foo";function foo()&#123; "use strict"; console.log(this.a);&#125;foo(); // TypeError：this is undefined 这里关于默认绑定的另一种情况需要注意：在严格模式下，全局对象将无法使用默认绑定，因此this会绑定到undefined。在ES6的class中，也会绑定到undefined 再看代码：12345678910111213141516171819class A &#123; constructor()&#123; this.aa = 1; &#125; hello()&#123; console.log(this.aa); &#125; hello2() &#123; (function()&#123; console.log(this.aa); &#125;)(); &#125;&#125;const a = new A();a.hello(); // 1a.hello2(); // Uncaught TypeError: Cannot read property 'aa' of undefined 证明了上面的绑定规则，绑定到了undefined。 react组件有了上面的铺垫，现在来谈谈react中的组件。在ES6中，react创建组件也就是使用class创建了一个“类”。123456789101112131415161718class View extends React.Component &#123; constructor(props)&#123; super(props); this.state=&#123; &#125; &#125; handleClick(e) &#123; console.log(e); &#125; render()&#123; return ( &lt;a onClick=&#123;this.handleClick&#125;&gt;click me&lt;/a&gt; ); &#125;&#125; 主要将注意力放在JSX的语法中，其中点击的回调方法对函数进行了this的绑定。但是前面a.hello();不是可以正常输出么？正常绑定了this么？为什么这里还需要进行绑定？ JSX想要搞清楚为什么需要绑定this，就需要搞清楚JSX到底是一个什么东西。我们看react官方的描述: 本质上来讲，JSX 只是为 React.createElement(component, props, ...children) 方法提供的语法糖。比如下面的代码：123&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 编译为：12345React.createElement( MyButton, &#123;color: &apos;blue&apos;, shadowSize: 2&#125;, &apos;Click Me&apos;) 如果没有子代，你还可以使用自闭合标签，比如： 1&lt;div className=&quot;sidebar&quot; /&gt; 编译为：12345React.createElement( &apos;div&apos;, &#123;className: &apos;sidebar&apos;&#125;, null) react官网深入jsx（中文） 去JSX后的react组件根据官网的描述，上面写的 View组件就变成了如下形式1234567891011121314151617class View extends React.Component &#123; constructor(props)&#123; super(props); &#125; handleClick(e) &#123; console.log(e); &#125; render()&#123; return React.createElement( "a", &#123; onClick: this.handleClick&#125;, "click me" ); &#125;&#125; 分析我们看React.createElement的第二个参数，传入的是一个对象，而这个对象里面有属性的值是取this 对象里面的属性 ，当这个对象放入React.createElement执行后，去取这个this.handleClick属性时候，this已经不是我们在书写的时候认为的绑定在View上了。this.handleClick这里的this就会像a.hello2的里面this绑定一样，this会默认绑定，但是又是在ES6的class中，所以this绑定了undefined，说到这就能说明标题了”为什么React组件点击事件回调函数会需要绑定this？”。 所以需要手动绑定this，在react中：(或者箭头函数)123456789101112131415class View extends React.Component &#123; constructor(props)&#123; super(props); &#125; handleClick(e) &#123; console.log(e); &#125; render()&#123; return ( &lt;a onClick=&#123;this.handleClick.bind(this)&#125;&gt;click me&lt;/a&gt; ); &#125;&#125; 有错误或者描述不清晰的地方，欢迎指正~]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>React</tag>
        <tag>class</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》学习笔记（四）：返回结果的HTTP状态码]]></title>
    <url>%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html</url>
    <content type="text"><![CDATA[HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。我们可以通过返回的状态码来判断请求是成功或者失败。 状态码类型 状态码 类别 原因短语 1XX Information（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加的操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务端错误状态码） 服务器处理请求出错 2XX 成功 200 OK 表示从客户端发来的请求在服务端被正常处理了。 204 No COntent 表示客户端请求成功但是服务器返回的内容没有实体的主体内容，也表示不能够返回实体的主体。场景：用在客户端像服务端发送内容，而客户端自己不需要做更新。 206 Partial Content 该状态码表示客户端进行了范围请求并且服务器c成功的执行了该GET请求。此时响应报文里面应该包含Content-Range字段来表示范围。 3XX 重定向 301 Moved Permanently 永久重定向。该状态码表示当前请求的资源已经被分配了新的URL，以后使用的话，应该访问新的URL。 302 Found 临时重定向。表名称当前请求的资源已经被分配了新的URL，希望客户端（本次）使用新的URL来访问。 303 See Other 该状态码表示由于请求对应的资源存在着另一个URL，应该使用GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。 304 Not Modified 该状态表示客户端发送附加条件的请求，而此时服务允许了请求，但是不满足条件,才返回该状态码，如果满足就返回200。 附加条件一般指的是：GET方法中请求报文中包含If-Mathc、If-Modified-Since、If-Not-Match等,其中的任一请求首部。 4XX 客户端错误 400 Bad Request 该状态码表明，客户端的请求报文中存在语法错误。当错误发生时，客户端需要重新修改请求内容后，重新发送请求。 401 Unauthorized 该状态码表示发送的请求需要通过HTTP认证(BASIC认证、DIGEST认证)。另外，如果用户已经进行过一次请求，那么返回401则表示认证失败。 403 Forbidden 该状态码表明客户端请求被服务端拒绝。此时服务端没有必要对拒绝的原因进行说明，但是如果需要给出，那么就可以在响应实体中加入说明，返回给客户端。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。 404 Not Found 该状态表明服务器上无法定位请求的资源。另外，也可以在服务器拒绝客户端请求但不想说明理由的时候返回该状态码。 5XX 服务器错误 500 Internal Server Error 该状态表明，服务器在处理请求的时候，服务端内部发生了错误。也可能是web应用存在着bug或者临时障碍。 503 Service Unavailable 该状态表明，服务器正处于超负载和停机维护中,现在无法处理请求。 状态码和状况的不一致不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。 github 欢迎Star，欢迎讨论]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》学习笔记（三）：HTTP报文内的HTTP信息]]></title>
    <url>%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF.html</url>
    <content type="text"><![CDATA[HTTP报文 用于HTTP协议交互的信息被称作为HTTP报文。请求端和服务端分别被叫做请求报文和响应报文。HTTP报文由报文首部和报文主体组成，首部和主体之间由【CR+LF】换行分割，一个HTTP报文不一定需要报文主体。 请求报文首部：请求行、请求首部字段、通用首部字段、实体首部字段、其他。 响应报文首部：状态行、响应首部字段、通用首部字段、实体首部字段、其他。 请求报文： 12345678910GET / HTTP/1.1 --请求行Host:www.baidu.comUser-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language:zh-CN,zh;q=0.8,en;q=0.6Accept-Encoding:gzip, deflate, brUpgrade-Insecure-Requests:1Cache-Control:max-age=0Connection:keep-alive --各种首部字段(CR-LF) --空行 响应报文： 12345678910111213141516171819202122HTTP/1.1 200 OK -- 状态行Bdpagetype:2Bdqid:0xb377d200000097b1Bduserid:1270621848Cache-Control:privateConnection:Keep-AliveContent-Encoding:gzipContent-Type:text/html;charset=utf-8Date:Wed, 18 Oct 2017 05:57:28 GMTExpires:Wed, 18 Oct 2017 05:57:28 GMTServer:BWS/1.1Set-Cookie:BDSVRTM=187; path=/Set-Cookie:BD_HOME=1; path=/Set-Cookie:H_PS_PSSID=1450_21119_20929; path=/; domain=.baidu.comStrict-Transport-Security:max-age=172800Transfer-Encoding:chunkedX-Ua-Compatible:IE=Edge,chrome=1 -- 各种首部字段(CR-LF) -- 空行&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt;... -- 响应主体 请求报文和响应报文的首部内容由以下数据组成： 请求行： 包含用于请求的方法，请求的URI和HTTP版本 状态行： 包含表面阐述响应结果的状态码，原因短语和HTTP版本 首部字段：包含表示请求和响应结果的各种条件和属性的各类首部。一般有4中首部，分别是：通用首部、请求首部、响应首部、实体首部。 其他： 可能包含HTTP的RFC里没有定义的首部（Cookie等）。 编码提升传输效率 通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU等资源。 报文主体和实体主体的差异 报文 是HTTP通信中的基本你单位，由8位字节流组成，通过HTTP通信传输。 实体 作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。 HTTP报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体，只有在传输中进行编码操作，实体主体的内容会发生变化，才导致它和报文主体产生差异。 压缩传输的内容编码 HTTP协议中有一种被称为内容编码的功能也能进行类型的操作，内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。 常用的内容编码有以下几种 gzip（GNU zip） compress （UNIX 系统的标准压缩） deflate （zlib） identity （不进行编码） 分割发送的分块传输编码 在HTTP通信过程中，请求的编码实体在没有全部传输完成之前，浏览器是无法显示请求页面的。所以在传输大量数据时，通常会把数据分割成多块。将这种技术称为 分块传输编码。 使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。 发送多种数据的多部分对象集合 发送邮件时，我们可以在邮件里写入文字并添加多发附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。 HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含多类型实体。通常是在图片或文本文件等上传时使用。 多部分对象集合包含的对象如下： multipart/form-data 在Web表单文件上传使用 multipart/byteranges 状态码206响应报文包含了多个范围的内容时使用。 multipart/form-data 123456789Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=&quot;field1&quot;Joe Blow--AaB03xContent-Disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;Content-Type: text/plain...（file1.txt的数据）...--AaB03x-- multipart/byteranges 12345678910111213HTTP/1.1 206 Partial ContentDate: Fri, 13 Jul 2012 02:45:26 GMTLast-Modified: Fri, 31 Aug 2007 02:02:20 GMTContent-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 500-999/8000...（范围指定的数据）...--THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 7000-7999/8000...（范围指定的数据）...--THIS_STRING_SEPARATES-- 获取部分内容的范围请求 以前的用户带宽不够，下载一个尺寸稍大的图片或者文件就会很吃力。如果下载过程中遇到网络问题中断了下载，那么就需要从头开始。为了解决上述问题，就产生了一种叫范围请求的功能。 对于一份10000字节大小的资源，如果使用范围请求，可以只请求5001~10000字节内的资源。 执行范围请求时，会用到首部字段Range来指定资源的byte范围： 1Range: bytes=5001-10000 // 5001-10000字节之间 1Range: bytes=5001- // 从5001字节之后全部 1Range: bytes=1-3000,5000-10000 // 多范围指定 针对范围请求，响应会返回206状态码。对于多重范围请求，响应会在首部字段Content-Type表明multipart/byteranges后返回响应报文 如果服务端无法响应范围请求，则会返回状态码200 OK然后返回完整的实体内容。 github 欢迎Star，欢迎讨论]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》学习笔记（二）：简单的HTTP协议]]></title>
    <url>%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[HTTP协议是用于客户端和服务端之间的通信 请求访问文本或图像等资源的一端称作为客户端，而提供资源的一端称作为服务端。 在一条HTTP通信线路上，客户端和服务端是确定，必须有一端是客户端和有一端是服务端。实际情况中，客户端、服务端的角色可能会互换，但是从仅从一条通信线路上说，这两端是确定的。 HTTP是不保存状态的协议HTTP协议自身不对请求和响应之间的通信状态进行保存。 简单的http协议 通信是从客户端开始建立的，客户端向服务端发送请求，服务端响应请求并且返回数据。那么就是通过请求和响应的交换达成通信。 客户端发送请求的例子： 12GET /index.html HTTP/1.1HOST: hackr.jp GET表示请求的方式、方法（method），/index.html表示请求指定资源，称为URI（request-URI），最后HTTP/1.1表示客户端使用的协议版本。 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 服务器响应的例子： 1234567HTTP/1.1 200 okDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 363Content-Type: text/html&lt;html&gt;... HTTP/1.1： 服务器的协议版本200 ok： 响应的状态码和原因短语（简短的解释）Date: Tue, 10 Jul 2012 06:50:15 GMT： 创建响应的时间下面就是首部字段，然后空一行就是内容实体。 告知服务器意图的HTTP方法 GET 获取资源 GET方法用来请求已被已被URI识别（存在的）的资源。指定的资源经服务器解析后返回响应内容。 POST 传输实体主体 向服务器传输主体，POST的主要目的并不是获取响应的主体内容。 PUT 传输文件 HEAD 获取报文的首部 与GET类似，只是响应不会返回报文主体部分，只有头部。 DELETE 删除文件 OPTIONS 询问支持的方法 用来查询针对请求URI指定的资源支持的方法。比如： 123456// 请求OPTIONS * HTTP/1.1Host: www.hackr.jp// 响应HTTP/1.1 200 OKAllow: GET,POST,HEAD,OPTIONS TRACE 追踪路径 客户端通过TRACE方法可以查询发出去的请求是怎么被加工修改、篡改的。一个请求想要连接到原目标服务器可能通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列的操作。但是TRACE方法本来不怎么常用，在加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会使用了 CONNECT 要求用隧道协议连接代理 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套装层）和TSL（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 持久连接节省通信量 HTTP初期的版本中，每进行一次通信就要断开一次TCP连接，以当年通信情况来说，因为都是容量小的文本传输，所以即使这样也没有什么问题，但是现在来看，文档中包含大量的图片是很平常的需求，所以这种通信一次就断掉的方法就不可取了。 为解决以上TCP通信问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是，只要任意一方没有提出明确的断开连接，则保持TCP连接状态。 在HTTP/1.1中，所有的默认连接都是持久连接，在HHTP/1.0中并没有标准化。客户端和服务端需要同时支持持久化才行。 使用Cookie的状态管理 HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也正是因为这一特性，自然可以减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是HTTP协议本事是非常简单的，所以才会被应用在各种场景中。 需要记录状态的场景：假设要求登录认证的Web页面本身无法进行状态管理（不记录的状态），那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。 在保留无状态这个特性的同是又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie是通过在请求和响应报文中写入Cookie信息来控制客户端的状态。 Cookie 会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发过来的请求中包含Cookie信息，拿着Cookie信息去服务器上的记录对比，来确定是哪一个客户端，做相应的操作。 相应的头部： 1.请求报文（没有Cookie信息状态） 123GET /reader/ HTTP/1.1Host: hackr.jp* 首部字段没有cookie的相关信息 2.响应报文（服务器生成Cookie信息） 12345HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache&lt;Set-Cookie: sid=1123423543234325; path=/; expires=Wed,10-Oct-12 07:12:20 GMT&gt;Content-Type: text/plain; charset=UTF-8 3.请求报文（自动发送保存着Cookie信息） 123GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1123423543234325 github 欢迎Star，欢迎讨论]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》学习笔记（一）：了解Web及网络基础]]></title>
    <url>%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[HTTP通常被翻译为“超文本传输协议”，但是这样的译法并不严谨。严谨的译法应该是“超文本转移协议”。但是前一译法已经约定俗成。有兴趣的可以参考图灵社区的相关讨论。 最初的设想的基本概念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW(World Wide Web，万维网)。 现在已经提出了3项WWW构建技术，分别是：把SGML（Standard Generalized Markup Language， 通用标记语言）作为页面的文本标记语言的HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator， 统一资源定位符）。 WWW : 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。 网络基础 TCP/IP：我们通常使用的网络（包括互联网）都是基于TCP/IP协议上的。所以HTTP是它内部的一个子集。 层级：应用层、传输层、网络层、链路层 各层级作用 应用层：应用层决定了向用户应用提供服务时的通信活动，TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（文件传输协议）和DNS（域名系统）服务就是其中两类。其中HTTP也是属于这层。 传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。有两个重要不同协议：TCP（传输控制协议）和UDP（用户数据报协议）。 网络层：网络层用来处理在网络上流动的数据包。该层规定了通过怎么样的路径到达目的计算机，并把数据传送给对方。在于对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输线路。 链路层：用来处理连接网络的硬件部分。硬件上的范畴均在链路层的作用范围内。（控制操作系统、硬件的设备光驱动、NIC。网卡等） 通信传输流图： 发送和接收： 发送端：由上直下，数据会经过层层的包裹，然后拆分成很多小报文包，然后发出。接收端：由下直上，数据会经过层层解包然后，将每个小报文组合成最终的数据。 整个发送接收图解： URI：统一资源标识符 URL：统一资源定位符 URL是URI的子集 （我的理解是， URI是一个资源的按特定规则取的“名字”，而URL是一个资源的地址，一个资源可以直接使用地址作为名字） github 欢迎Star，欢迎讨论]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中扩展符（spread/rest）的各种表现]]></title>
    <url>%2FJS%E4%B8%AD%E6%89%A9%E5%B1%95%E7%AC%A6%EF%BC%88spread-rest%EF%BC%89%E7%9A%84%E5%90%84%E7%A7%8D%E8%A1%A8%E7%8E%B0.html</url>
    <content type="text"><![CDATA[每一天都以许下希望开始，以收获经验结束。 深入 ‘…’ 各种情况下的表现形式在js中，合并多个对象是一种很常见的操作，在ES5的时候，没有一种很方便的语法来进行对象的合并。在ES6中引入了一个对象函数Object.assgin(source, [target])，再之后又引入了对象的spread语法。 如下：123456789101112131415const cat = &#123; legs: 4, sound: 'meow',&#125;;const dog = &#123; ...cat, sound: 'woof'&#125;;/* 最后结果dog =&gt; &#123; legs: 4, sound: 'woof',&#125;*/ spread与属性的可枚举配置在ES5及之后的规范中，对象的每一个属性都存在几个来描述该属性的属性。这些值用来描述对象的属性是否可写、可枚举和可配置的状态。这里只说可枚举属性，可枚举属性是一个bool值，代表对象属性是否可以被访问。我们可以使用Object.keys()来访问自己的和可枚举属性,也可以使用for...in语句来遍历所有可枚举的属性如下：123456789101112const person = &#123; name: 'zachrey', age: 21,&#125;;Object.keys(person); // ['name', 'age']console.log(&#123;...person&#125;);/*&#123; name: 'zachrey', age: 21,&#125;*/ 所以name age是person对象中的可枚举属性，目前来说spread可以克隆所有的可枚举属性。现在我们来给person定义一个不可以枚举的属性，再使用spread看能不能克隆出来。1234567891011121314151617Object.defineProperty(person, 'sex', &#123; enumerable: false, value: 'male',&#125;);console.log(person['sex']);// maleconst clonePerson = &#123; ...person,&#125;;console.log(Object.keys(person));// ['name', 'age']console.log(clonePerson);/*&#123; name: 'zachrey', age: 21,&#125;*/ 通过以上可以看出来： 不可枚举属性，可以被访问，使用console.log打印出来。 ...并不能克隆不可枚举属性。 ...的表现形式与Object.keys的表现形式相同。 spread与自身属性对于一个js对象，它的属性可以是自己的也可能是原型链上的，接下来简单的实现以下继承。123456789const personB = Object.create(person, &#123; profession: &#123; value: 'development', enumerable: true, &#125;&#125;);console.log(personB.hasOwnProperty('profession')); // =&gt; trueconsole.log(personB.hasOwnProperty('name')); // =&gt; falseconsole.log(personB.hasOwnProperty('age')); // =&gt; false 如上，只有profession是属于personB自身的。Object spread从自己的源属性中进行复制的时候，会忽略继承的属性。如下：12const cloneB = &#123; ...personB &#125;;console.log(cloneB); // =&gt; &#123; profession: 'development' &#125; Object spread可以从源对象中复制自己的和可枚举的属性。和Object.keys()相同。 Object spread规则：最后属性获胜 后者扩展属性覆盖具有相同键的早期属性 如下：123456789101112131415161718const cat = &#123; sound: 'meow', legs: 4,&#125;;const dog = &#123; ...cat, ...&#123; sound: 'woof' // &lt;----- 覆盖 cat.sound &#125;&#125;;console.log(dog); // =&gt; &#123; sound: 'woof', legs: 4 &#125;const anotherDog = &#123; ...cat, sound: 'woof' // &lt;---- Overwrites cat.sound&#125;;console.log(anotherDog); // =&gt; &#123; sound: 'woof', legs: 4 &#125; 浅拷贝spread对值是复合类型的属性，只会拷贝它对该值得应用。如下：12345678const laptop = &#123; name: 'MacBook Pro', screen: &#123; size: 17, isRetina: true &#125;&#125;;const laptopClone = &#123; ...laptop &#125;;console.log(laptop === laptopClone); // =&gt; falseconsole.log(laptop.screen === laptopClone.screen); // =&gt; true 首先比较laptop === laptopClone，其值是false。主对象被正确克隆。 然而，laptop.screen === laptopClone.screen值是true。这意味着，laptop.screen和laptopClone.screen引用相同的嵌套对象，但没有复制。 原型丢失这里先声明一个类：1234567891011class Game &#123; constructor(name) &#123; this.name = name; &#125; getMessage() &#123; return `I like $&#123;this.name&#125;!`; &#125;&#125;const doom = new Game('Doom');console.log(doom instanceof Game); // =&gt; true console.log(doom.name); // =&gt; "Doom"console.log(doom.getMessage()); // =&gt; "I like Doom!" 接下来我们使用spread克隆调用构造函数创建的doom实例：1234const doomClone = &#123; ...doom &#125;;console.log(doomClone instanceof Game); // =&gt; falseconsole.log(doomClone.name); // =&gt; "Doom"console.log(doomClone.getMessage()); // =&gt; TypeError: doomClone.getMessage is not a function ...doom只将自己的属性name复制到doomClone而已。doomClone是一个普通的JavaScript对象，其原型是Object.prototype，而不是Game.prototype，这是可以预期的。Object Spread不保存源对象的原型。想要修复原型可以使用Object.setPrototypeOf(doomClone, Game.prototype)。使用Object.assign()可以更合理的克隆doom：1234const doomFullClone = Object.assign(new Game(), doom);console.log(doomFullClone instanceof Game); // =&gt; trueconsole.log(doomFullClone.name); // =&gt; "Doom"console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 传播undefined、null和基本类型123456const nothing = undefined;const missingObject = null;const two = 2;console.log(&#123; ...nothing &#125;); // =&gt; &#123; &#125;console.log(&#123; ...missingObject &#125;); // =&gt; &#123; &#125;console.log(&#123; ...two &#125;); // =&gt; &#123; &#125; 总结Object spread有一些规则要记住： 它从源对象中提取自己的和可枚举的属性 扩展的属性具有相同键的，后者会覆盖前者 与此同时，Object spread是简短而且富有表现力的，同时在嵌套对象上也能很好的工作，同时也保持更新的不变性。它可以轻松的实现对象克隆、合并和填充默认属性。 在结构性赋值中使用Object rest语法，可以收集剩余的属性。 实际上，Object rest和Object spread是JavaScript的重要补充。 原文链接]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发百度地图插件]]></title>
    <url>%2Freact-native%E5%BC%80%E5%8F%91%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[参考官网： 开发原生UI组件（http://reactnative.cn/docs/0.43/native-component-android.html#content） 一起五个步骤： 创建一个ViewManager的子类。 实现createViewInstance方法。 导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。 把这个视图管理类注册到应用程序包的createViewManagers里。 实现JavaScript模块 首先将react-native目录下的android目录用android studio打开：之后就是对组件的开发过程了。 首先进入百度地图的官网，下载相应的android sdk。先申请密钥。下载需要的jar和so文件：百度地图的环境配置：官网地址（http://lbsyun.baidu.com/index.php?title=androidsdk/guide/buildproject） Android Studio工程配置方法：第一步：在工程app/libs目录下放入baidumapapi_vX_X_X.jar包，在src/main/目录下新建jniLibs目录，工程会自动加载src目录下的so动态库，放入libBaiduMapSDK_vX_X_X_X.so，注意jar和so的前3位版本号必须一致，并且保证使用一次下载的文件夹中的两个文件，不能不同功能组件的jar或so交叉使用。 第二步：工程配置还需要把jar包集成到自己的工程中，放入libs目录下。对于每个jar文件，右键-选择Add As Library，导入到工程中。对应在build.gradle生成工程所依赖的jar文件说明. jar的配置也可参考eclipse方法，进行以下操作：菜单栏选择 File —&gt;Project Structure。在弹出的Project Structure 对话框中, 选择module, 然后点击 Dependencies 选项卡。 第三步： 在AndroidManifest中添加开发密钥、所需权限等信息； （1）在application中添加开发密钥12345&lt;application&gt; &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;开发者 key&quot;/&gt;&lt;/application&gt; 2）添加所需权限123456789&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt; 第四步，在应用程序创建时初始化 SDK引用的Context 全局变量：SDKInitializer.initialize(getApplicationContext());//先省略不做这一步的操作之后会以另外的方式代替 目前的app里面的目录结构： 以上，android原生的百度地图开发环境已经配置完成。 现在就来创建BaiduMapViewManager.java和包管理类(MyPackageManager.java): BaiduMapViewManage继承于 SimpleViewManager 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class BaiduMapViewManager extends SimpleViewManager&lt;MapView&gt; implements BaiduMap.OnMapLoadedCallback &#123; public static final String RCT_CLASS = &quot;RCTBaiduMap&quot;; //react-native中js来识别的标示，用于getName方法返回。 public static final String TAG = &quot;RCTBaiduMap&quot;; private ThemedReactContext mReactContext; public static final int ruler = 16; @Override public String getName() &#123; return RCT_CLASS; &#125; //初始化百度地图sdk的方法，该方法在包管理类里面构造函数里面调用。重要 public void initSDK(Context context) &#123; SDKInitializer.initialize(context); &#125; @Override protected MapView createViewInstance(ThemedReactContext reactContext) &#123; this.mReactContext = reactContext; return getMap(reactContext); &#125; //这里实例化地图的视图，需要一个context，由createViewInstance函数传入就好 private MapView getMap(ThemedReactContext reactContext) &#123; MapView mMapView = new MapView(reactContext); mMapView.showZoomControls(false); BaiduMap baiduMap = mMapView.getMap(); baiduMap.animateMapStatus(MapStatusUpdateFactory.zoomTo(ruler), 1 * 1000); baiduMap.setOnMapLoadedCallback(this); return mMapView; //最后返回地图 &#125; /** * 地图模式 * * @param mapView * @param type * 1. 普通 * 2.卫星 */ @ReactProp(name=&quot;mode&quot;, defaultInt = 1) public void setMode(MapView mapView, int type) &#123; Log.i(TAG, &quot;mode:&quot; + type); mapView.getMap().setMapType(type); &#125; /** * 实时交通图 * * @param mapView * @param isEnabled */ @ReactProp(name=&quot;trafficEnabled&quot;, defaultBoolean = false) public void setTrafficEnabled(MapView mapView, boolean isEnabled) &#123; Log.d(TAG, &quot;trafficEnabled:&quot; + isEnabled); mapView.getMap().setTrafficEnabled(isEnabled); &#125; /** * 实时道路热力图 * * @param mapView * @param isEnabled */ @ReactProp(name=&quot;heatMapEnabled&quot;, defaultBoolean = false) public void setHeatMapEnabled(MapView mapView, boolean isEnabled) &#123; Log.d(TAG, &quot;heatMapEnabled&quot; + isEnabled); mapView.getMap().setBaiduHeatMapEnabled(isEnabled); &#125; //实现接口BaiduMap.OnMapLoadedCallback的重写方法，用于地图加载后的监听。这里没有实现。 @Override public void onMapLoaded() &#123; &#125;&#125; MyReactPackage 实现于接口ReactPackage代码如下：123456789101112131415161718192021222324252627public class MyReactPackage implements ReactPackage &#123; private Context mContext; BaiduMapViewManager baiduMapViewManager; //书写包管理类的构造方法，参数为一个Context，该Context用于初始化百度地图的SDK，也就是ViewManager里面的initSDK方法 public MyReactPackage(Context context) &#123; this.mContext = context; baiduMapViewManager = new BaiduMapViewManager(); baiduMapViewManager.initSDK(context); &#125; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules=new ArrayList&lt;&gt;(); //将我们创建的类添加进原生模块列表中 modules.add(new RNModule(reactContext)); return modules; //所写的原生组件，在这里加入，并创建 &#125; @Override public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123; return Collections.emptyList(); &#125; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Arrays.&lt;ViewManager&gt;asList( new ReactWebViewManager(), new BaiduMapViewManager()); //所写的原生ViewManager类都需要在这里实例化，然后创建 &#125;&#125; 我们创建的packageManager都需要在MainApplication里面进行注册，我们只需要关注getPackages这个方法MainApplication代码如下： 123456789101112131415161718192021222324public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override public boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new MyReactPackage(getApplicationContext()) //在这里注册packageManager，并且传入一个Context。 ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; @Override public void onCreate() &#123; super.onCreate(); SoLoader.init(this, /* native exopackage */ false); &#125;&#125; MainActivity不需要动。 以上在android studio进行的开发完毕，现在转移到react-native里面的js开发。创建一个模板：比如BaiduMap.js内容如下：1234567891011121314import &#123; PropTypes &#125; from &apos;react&apos;;//在react-native里面导出requireNativeComponentimport &#123; requireNativeComponent, View &#125; from &apos;react-native&apos;;//声明一个原生视图组件的各个参数。var iface = &#123; name: &apos;BaiduMap&apos;, //名字， 之后就这样使用&lt;BaiduMap&gt;&lt;/BaiduMap&gt; propTypes: &#123; mode: PropTypes.number, //根据android里面ViewManager一一对应 trafficEnabled: PropTypes.bool, heatMapEnabled: PropTypes.bool, ...View.propTypes // 包含默认的View的属性 可以使用style等、、 &#125;,&#125;;module.exports = requireNativeComponent(&apos;RCTBaiduMap&apos;, iface); //可以理解为关联，js与java的关联。 使用：MyBaiduMap.js： 123456789101112131415161718192021import React, &#123;Component&#125; from &apos;react&apos;;import &#123; View, Text, StyleSheet&#125; from &apos;react-native&apos;;var BaiduMap = require(&apos;../AndroidView/BaiduMap&apos;); //获取之前创建的模板class BaiduMapView extends Component &#123; render()&#123; return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;BaiduMap style=&#123;&#123;height: &apos;100%&apos;, width: &apos;100%&apos;&#125;&#125; //注意， 最好设置高宽。 mode=&#123;1&#125; //这里就是依次的props trafficEnabled=&#123;false&#125; heatMapEnabled=&#123;false&#125; &gt;&lt;/BaiduMap&gt; &lt;/View&gt; ); &#125;&#125;export default BaiduMapView; 百度地图初步的展示，到这里就ok了。（花了两天的时间，知道了react-native还能这样用。android studio能配合调试原生插件，只要先开启react-native服务（react-native start），然后在运行android studio的调试系统。设置断点是一样的。）。]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript同步、异步、回调执行顺序之经典闭包setTimeout分析]]></title>
    <url>%2FJavaScript%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%9B%9E%E8%B0%83%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%B9%8B%E7%BB%8F%E5%85%B8%E9%97%AD%E5%8C%85setTimeout%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[https://segmentfault.com/a/1190000008922457 同步、异步、回调？傻傻分不清楚。 大家注意了，教大家一道口诀： 同步优先、异步靠边、回调垫底（读起来不顺） 用公式表达就是： 同步 =&gt; 异步 =&gt; 回调 这口诀有什么用呢？用来对付面试的。 有一道经典的面试题： 1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log('i: ',i); &#125;, 1000);&#125;console.log(i); 12345678//输出5i: 5i: 5i: 5i: 5i: 5console.log(i); 这道题目大家都遇到过了吧，那么为什么会输出这个呢？记住我们的口诀 同步 =&gt; 异步 =&gt; 回调 1、for循环和循环体外部的console是同步的，所以先执行for循环，再执行外部的console.log。（同步优先） 2、for循环里面有一个setTimeout回调，他是垫底的存在，只能最后执行。（回调垫底） 那么，为什么我们最先输出的是5呢？ 非常好理解，for循环先执行，但是不会给setTimeout传参（回调垫底），等for循环执行完，就会给setTimeout传参，而外部的console打印出5是因为for循环执行完成了。 这里涉及到JavaScript执行栈和消息队列的概念，概念的详细解释可以看阮老师的 JavaScript 运行机制详解:再谈Event Loop - 阮一峰的网络日志，或者看 并发模型与Event Loop 《图片来自于MDN官方》 我拿这个例子做一下讲解，JavaScript单线程如何处理回调呢？JavaScript同步的代码是在堆栈中顺序执行的，而setTimeout回调会先放到消息队列，for循环每执行一次，就会放一个setTimeout到消息队列排队等候，当同步的代码执行完了，再去调用消息队列的回调方法。 在这个经典例子中，也就是说，先执行for循环，按顺序放了5个setTimeout回调到消息队列，然后for循环结束，下面还有一个同步的console，执行完console之后，堆栈中已经没有同步的代码了，就去消息队列找，发现找到了5个setTimeout，注意setTimeout是有顺序的。 那么，setTimeout既然在最后才执行，那么他输出的i又是什么呢？答案就是5。。有人说不是废话吗？ 现在告诉大家为什么setTimeout全都是5，JavaScript在把setTimeout放到消息队列的过程中，循环的i是不会及时保存进去的，相当于你写了一个异步的方法，但是ajax的结果还没返回，只能等到返回之后才能传参到异步函数中。在这里也是一样，for循环结束之后，因为i是用var定义的，所以var是全局变量（这里没有函数，如果有就是函数内部的变量），这个时候的i是5，从外部的console输出结果就可以知道。那么当执行setTimeout的时候，由于全局变量的i已经是5了，所以传入setTimeout中的每个参数都是5。很多人都会以为setTimeout里面的i是for循环过程中的i，这种理解是不对的。 ===========================================分割线========================================= 看了上面的解释，你是不是有点头晕，没事，继续深入讲解。 我们给第一个例子加一行代码。 123456789for (var i = 0; i &lt; 5; ++i) &#123; setTimeout(function() &#123; console.log('2: ',i); &#125;, 1000); console.log('1: ', i); //新加一行代码&#125;console.log(i); 123456789101112//输出1: 01: 11: 21: 31: 452: 52: 52: 52: 52: 5 来，大家再跟着我一起念一遍：同步 =&gt; 异步 =&gt; 回调 （强化记忆） 这个例子可以很清楚的看到先执行for循环，for循环里面的console是同步的，所以先输出，for循环结束后，执行外部的console输出5，最后再执行setTimeout回调 55555。。。 =====================================分割线============================================ 这么简单，不够带劲是不是，那么面试官会问，怎么解决这个问题？ 最简单的当然是let语法啦。。 12345678for (let i = 0; i &lt; 5; ++i) &#123; setTimeout(function() &#123; console.log('2: ',i); &#125;, 1000);&#125;console.log(i); 1234567//输出i is not defined2: 02: 12: 22: 32: 4 咦，有同学问，为什么外部的i报错了呢？又有同学问，你这个口诀在这里好像不适应啊？ let是ES6语法，ES5中的变量作用域是函数，而let语法的作用域是当前块，在这里就是for循环体。在这里，let本质上就是形成了一个闭包。也就是下面这种写法一样的意思。如果面试官对你说用下面的这种方式，还有let的方式，你可以严肃的告诉他：这就是一个意思！这也就是为什么有人说let是语法糖。 1234567891011var loop = function (_i) &#123; setTimeout(function() &#123; console.log('2：', _i); &#125;, 1000);&#125;;for (var _i = 0; _i &lt; 5; _i++) &#123; loop(_i);&#125;console.log(i); 面试官总说闭包、闭包、闭包，什么是闭包？后面再讲。 写成ES5的形式，你是不是发现就适合我说的口诀了？而用let的时候，你发现看不懂？那是因为你没有真正了解ES6的语法原理。 我们来分析一下，用了let作为变量i的定义之后，for循环每执行一次，都会先给setTimeout传参，准确的说是给loop传参，loop形成了一个闭包，这样就执行了5个loop，每个loop传的参数分别是0，1，2，3，4，然后loop里面的setTimeout会进入消息队列排队等候。当外部的console执行完毕，因为for循环里的i变成了一个新的变量 _i ，所以在外部的console.log(i)是不存在的。 现在可以解释闭包的概念了：当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 我知道你又要我解释这句话了，loop(_i)是外部函数，setTimeout是内部函数，当setTimeout被loop的变量访问的时候，就形成了一个闭包。（别说你又晕了） 随便举个新的例子。12345678function t() &#123; var a = 10; var b = function() &#123; console.log(a); &#125; b();&#125;t(); //输出 10 跟我一起念口诀：同步 =&gt; 异步 =&gt; 回调 （强化记忆）先执行函数t，然后js就进入了t内部，定义了一个变量，然后执行函数b，进入b内部，然后打印a，这里都是同步的代码，没什么异议，那么这里怎么解释闭包：函数t是外部函数，函数b是内部函数，当函数b被函数t的变量访问的时候，就形成了闭包。 ========================================分割线============================================== 上面主要讲了同步和回调执行顺序的问题，接着我就举一个包含同步、异步、回调的例子。 123456789101112131415161718192021let a = new Promise( function(resolve, reject) &#123; console.log(1) setTimeout(() =&gt; console.log(2), 0) console.log(3) console.log(4) resolve(true) &#125;)a.then(v =&gt; &#123; console.log(8)&#125;)let b = new Promise( function() &#123; console.log(5) setTimeout(() =&gt; console.log(6), 0) &#125;)console.log(7) 看到这个例子，千万不要害怕😨，先读一遍口诀：同步 =&gt; 异步 =&gt; 回调 （强化记忆） 1、看同步代码：a变量是一个Promise，我们知道Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的，所以这里先执行a变量内部的Promise同步代码。（同步优先） 1234console.log(1) setTimeout(() =&gt; console.log(2), 0) //回调 console.log(3) console.log(4) 2、Promise内部有4个console，第二个是一个setTimeout回调（回调垫底）。所以这里先输出1，3，4回调的方法丢到消息队列中排队等着。 3、接着执行resolve(true)，进入then()，then是异步，下面还有同步没执行完呢，所以then也滚去消息队列排队等候。（真可怜）（异步靠边）4、b变量也是一个Promise，和a一样，执行内部的同步代码，输出5，setTimeout滚去消息队列排队等候。 5、最下面同步输出7。 6、同步的代码执行完了，JavaScript就跑去消息队列呼叫异步的代码：异步，出来执行了。这里只有一个异步then，所以输出8。 7、异步也over，轮到回调的孩子们：回调，出来执行了。这里有2个回调在排队，他们的时间都设置为0，所以不受时间影响，只跟排队先后顺序有关。则先输出a里面的回调2，最后输出b里面的回调6。 8、最终输出结果就是：1、3、4、5、7、8、2、6。 我们还可以稍微做一点修改，把a里面Promise的 setTimeout(() =&gt; console.log(2), 0)改成 setTimeout(() =&gt; console.log(2), 2)，对，时间改成了2ms，为什么不改成1试试呢？1ms的话，浏览器都还没有反应过来呢。你改成大于或等于2的数字就能看到2个setTimeout的输出顺序发生了变化。所以回调函数正常情况下是在消息队列顺序执行的，但是使用setTimeout的时候，还需要注意时间的大小也会改变它的顺序。 ====================================分割线================================================== 口诀不一定是万能的，只能作为一个辅助，更重要的还是要理解JavaScript的运行机制，才能对代码执行顺序有清晰的路线。 还有async/await等其他异步的方案，不管是哪种异步，基本都适用这个口诀，对于新手来说，可以快速读懂面试官出的js笔试题目。以后再也不用害怕做笔试题啦。 特殊情况下不适应口诀的也很正常，JavaScript博大精深，不是一句话就能概括出来的。 最后，在跟着我念一遍口诀：同步 =&gt; 异步 =&gt; 回调]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动前端开发viewport深入理解]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-viewport-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一个网页在pc端和移动端能统一适配，关键因素就在于viewport。在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 一、viewport的概念viewport就是设备上用来显示网页的那一块区域，再具体一点就是，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。 二、css中的1px并不等于设备的1px 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。css样式里面的px和物理像素并不是相等的，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。 在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西。 三、viewport的三个理论 首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。 但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 再总结一下：把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 四、利用meta标签对viewport进行控制 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？ meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。 在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下： width: 设置layout viewport 的宽度，为一个正整数，或字符串”width-device” initial-scale: 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数 height: 设置layout viewport 的高度，这个属性对我们并不重要，很少使用 user-scalable: 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素。 target-densitydpi: 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用。 五、把当前的viewport宽度设置为 ideal viewport 的宽度要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。 这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。 这样的设置，也能达到相同的结果1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。 因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？ 要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了 后是否能把当前的viewport宽度变成 ideal viewport 的宽度的测试结果。 测试结果表明 initial-scale=1 也能把当前的viewport宽度变成 ideal viewport 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。但这点小瑕疵已经无关紧要了。 但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？比如：1&lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt; width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度） 最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 六、结语首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事。 第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 来得到一个理想的viewport（也就是前面说的ideal viewport）。 为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript作用域]]></title>
    <url>%2Fjavascript%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。 词法作用域考虑以下代码：12345678 function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 );&#125;foo( 2 ); // 2, 4, 12在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。 包含着整个全局作用域，其中只有一个标识符： foo 。 包含着 foo 所创建的作用域，其中有三个标识符： a 、 - bar 和 b 。 包含着 bar 所创建的作用域，其中只有一个标识符： c 。 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 JavaScript 中有两个机制可以“欺骗”词法作用域： eval(..) 和 with 。但一般不建议使用，这里不多做介绍。 函数作用域和块作用域JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，下面我们来看一下。 考虑下面的代码：123456789function foo(a) &#123; var b = 2; // 一些代码 function bar() &#123; // ... &#125; // 更多的代码 var c = 3;&#125; 在这个代码片段中， foo(..) 的作用域气泡中包含了标识符 a 、b 、 c 和 bar 。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标识符： foo 。由于标识符 a 、 b 、 c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的代码会导致 ReferenceError 错误： bar(); // 失败 console.log( a, b, c ); // 三个全都失败但是，这些标识符（ a 、 b 、 c 、 foo 和 bar ）在 foo(..) 的内部都是可以被访问的，同样在bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。 隐藏内部实现 对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。 实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。例如：123456789function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内容隐藏在 doSomething(..) 内部，例如：123456789function doSomething(a) &#123; function doSomethingElse(a) &#123; return a - 1; &#125; var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;doSomething( 2 ); // 15现在， b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。 函数作用域我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。1234567var a = 2;function foo() &#123; // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3&#125; // &lt;-- 以及这一行foo(); // &lt;-- 以及这一行console.log( a ); // 2 虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 foo() ，意味着 foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（ foo() ）调用这个函数才能运行其中的代码。如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。 幸好，JavaScript 提供了能够同时解决这两个问题的方案:123456var a = 2;( function foo()&#123; // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3&#125;)(); // &lt;-- 以及这一行console.log( a ); // 2(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 匿名和具名对于函数表达式最熟悉的场景可能就是回调参数了，比如：123setTimeout( function() &#123; console.log("I waited 1 second!");&#125;, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：123setTimeout( function timeoutHandler() &#123; // &lt;-- 快看，我有名字了！ console.log( "I waited 1 second!" );&#125;, 1000 ); 立即执行函数表达式123456var a = 2;(function foo() &#123; var a = 3; console.log( a ); // 3&#125;)();console.log( a ); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。 这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）； 函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。 相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式： (function(){ .. }()) 。仔细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。 这两种形式在功能上是一致的。选择哪个全凭个人喜好。 IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。例如：1234567var a = 2;(function IIFE( global ) &#123;var a = 3;console.log( a ); // 3console.log( global.a ); // 2&#125;)( window );console.log( a ); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global ，因此在代码风格上对全局 对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。 块作用域 除 JavaScript 外的很多编程语言都支持块作用域，因此其他语言的开发者对于相关的思维方式会很熟悉，但是对于主要使用 JavaScript 的开发者来说，这个概念会很陌生。 123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i ，通常是因为只想在 for 循环内部的上下文中用 i ，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。另外一个例子：123456var foo = true;if (foo) &#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125;bar 变量仅在 if 声明的上下文中使用，因此如果能将它声明在 if 块内部中会是一个很有意义的事情。但是，当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。 try/catch非常少有人会注意到 JavaScript 的 ES3 规范中规定 try / catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。1234567try &#123; undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123; console.log( err ); // 能够正常执行！&#125;console.log( err ); // ReferenceError: err not found let到目前为止，我们知道 JavaScript 在暴露块作用域的功能中有一些奇怪的行为。如果仅仅是这样，那么 JavaScript 开发者多年来也就不会将块作用域当作非常有用的机制来使用了。幸好，ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。1234567var foo = true;if (foo) &#123; let bar = foo * 2; bar = something( bar ); console.log( bar );&#125;console.log( bar ); // ReferenceError let 循环:一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。1234for (let i=0; i&lt;10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError下面通过另一种方式来说明每次迭代时进行重新绑定的行为：1234567&#123; let j; for (j=0; j&lt;10; j++) &#123; let i = j; // 每个迭代重新绑定！ console.log( i ); &#125;&#125; const除了 let 以外，ES6 还引入了 const ，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常 ! b = 4; // 错误 !&#125;console.log( a ); // 3console.log( b ); // ReferenceError! 小结 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。 从 ES3 开始， try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（ var 关键字的表亲），用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。 提升 到现在为止，已经很熟悉作用域的概念，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。但是作用域同其中的变量声明出现的位置有某种微妙的联系。 先有鸡还是先有蛋直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。考虑以下代码：123a = 2;var a;console.log( a );你认为 console.log(..) 声明会输出什么呢？很多人会认为是 undefined ，因为 var a 声明在 a = 2 之后，他们自然而然地认为变量被重新赋值了，因此会被赋予默认值 undefined 。但是，真正的输出结果是 2 。 编译器当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明： var a; 和 a =2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。我们的第一个代码片段会以如下形式进行处理：123var a;a = 2;console.log( a );因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。看着这样的代码：12345foo();function foo() &#123; console.log( a ); // undefined var a = 2;&#125;foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。变成这样：123456function foo() &#123; var a; console.log( a ); // undefined a = 2;&#125;foo();可以看到，函数声明会被提升，但是函数表达式却不会被提升。1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123;// ...&#125;; 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。12345678foo(); // 1var foo; function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;;会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;;注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。12345678910foo(); // 3function foo() &#123; console.log( 1 );&#125;var foo = function() &#123; console.log( 2 );&#125;;function foo() &#123; console.log( 3 );&#125; 小结 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 代码段来至于《你不知道的javascript》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年时光轴]]></title>
    <url>%2F2016%E5%B9%B4%E6%97%B6%E5%85%89%E8%BD%B4.html</url>
    <content type="text"><![CDATA[2016年时光轴 ２０１６年，在工作的充实下，时间好像过的更快。5月中旬，接触了APPCAN这种混合开发平台，当时几天培训和讲解，也是弄得一头雾水。没办法，当时听不懂，所以就恶补了下前端的基础知识，最后就能慢慢的动手了。当时一起考初级、中级认证是最激动的时候。不过好在有老师和几个伙伴的陪伴下，我们一起顺利的拿下了认证，也得到了公司初次合作的认可。 5月 第一个练手项目，第一次接触项目需求分析会议，听得非常认真，在为期20天左右的开发时间中，每天都会碰到问题并去解决问题，那时可能也把APPCAN的技术经理麻烦了一阵子吧。最终还是顺利完成，认识到了APPCAN这个平台的方便，也认识到了自己知识的不足。以微茫的知识，就能开发出一个Android和IOS都能跑的APP，此时，自己感到了一丝成就感，之后将APP上传到IOS的APP商店费了不少精力，查询的资料何其多，解决问题就应该坚持不懈，不断尝试。 6，7月 中间休息了一段时间，闲的时候，就加强练习下HTML+CSS+JS的知识体系，在此“慕课网”给我的帮助还是真不少，当然，这里面只能叫我入门的知识。更多的还是在网上的论坛、博客上看别人的解答。到此，JS的灵活激发了我一丝好奇心，希望把它能更好的掌握和设计。 学习了一段时间的JS，迎来了第二个项目。最开始，拿到了一种红外扫码的定制设备，相对来说比第一个项目的难度要大，前后台数据交互很多，好的是以前有一点后端服务的概念，知道数据交互的流程，能勉强按要求去完成，学会和后端人员沟通，并定制接口数据，是我在这个项目得到的最大的收获，虽然“大冶有色”也需要沟通，但是规模会比这个要小。 8,9月 第二个项目“长高条码管理系统”，时间较长，2个月左右，开发用了一个月，之后剩下的就是维护了。维护的期间就在学校和公司穿梭，因为没有什么很大的问题，所以那一段时间是很放松的。这个时候开始了培训第二批队员的计划，因此，走上了讲台。平时常在“慕课网”上面听各种老师授课，并且大二上学期做过半学期的C语言助教，单独讲授过几次课，算是有过点经验，但是第一次开始的时候，还是适应了一段时间。觉得还是要认真备课，因为临场敲击代码，真的很难做到正确和准确。 10,11,12月 10月开始，进行类似于“长高条码管理系统”的第三个项目，目前就进行到这里，一直都在增加和更改。着实忙了很大一段时间。最初说的是10月25交成功，所以不停的赶进度，最后这个时间无限的往后延迟，剩下的就是无尽的维护和更改。因为类似于之前的“长高条码管理系统”，在维护中产生了很大的厌倦情绪，在临近期末考试的时期尤为明显，伙伴们都产生了这种情绪，这也许就是初到“职场”的浮躁。时间的磨练，最后将这种情绪很好的沉淀下来了，现在公司闲暇的时候，看看技术文摘，大有精神的时候就学android或者NodeJS，在此期间还是用Python写了一个根据时间删除指定文件内容的小工具代码，最后使用，感觉没有想象中的好用；使用NodeJs和github等一些平台搭建了一个属于自己的博客，也算是年终很好的安慰了。 不足和需改进方面： 要充分利用在公司的闲余时间，学学英语也是好的。 项目初始设计的时候加强大局观，以便于维护、修改、扩展为前提，不能以前期方便为主。 文档记录具体、正规化。 处理很多事情时，必须划分重要等级，依次处理。]]></content>
      <categories>
        <category>Plans</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript正则表达式]]></title>
    <url>%2Fjavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[javascript &amp; 正则表达式 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式并不是javascript所特有的，很多语言都支持正则，但是每种语言对正则表达式的支持或多或少会存在差别。 正则表达式在js中的存在形式在js中，我们可以使用RegExp和字面量来创建正则表达式的对象。RegExp对象：1var re = new RegExp('abc');字面量：1var re = /abc/;正则表达式有三种模式：（全局）global， （忽略大小写）ignoreCase， （多行搜索）multiLines开启的方式为：1var re = new RegExp('abc','igm');或者1var re = /abc/igm; i -&gt; 执行对大小写不敏感的匹配。 g -&gt; 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m -&gt; 执行多行匹配。 正则表达式组成形式 原义字符 ： 字符本身的意思 ，例如 a就是字母a 元字符 ：在正则表达式中有特殊含义的非字母字符，例如：* + ^ $ . | \ ( ) { } [ ] /a/ /a*/ /a+/ … 字符类一般情况下正则表达式里面的一个字符对应字符串中的一个字符。 /abc/ 对应字符串”abc”，不对应”abcd”和”ab”等。 使用”[ ]”元字符来构建一个类（类是一个泛指符合某些特征性对象，而不是特殊的指一个字符）。 /[abc]/ 指的可以匹配一个字符，这个字符必须是a,b,c三个中的其中一个。/[^abc]/ 可以匹配一个字符，这个字符必须不是a,b,c三个中的其中任何一个。 1234567str = 'a1b2c3d4';result = str.replace(/[abc]/g, 'X'); //匹配a,b,c三个中任何一个。 a or b or cconsole.log(result); //X1X2X3d4result = str.replace(/[^abc]/g, 'X'); //匹配不为a,b,c三个中任何一种。 !a and !b and !cconsole.log(result); //aXbXcXXX 范围类 [a-z] 可以匹配一个字符，改字符必须为a,b,c,d…z 中的一个[a-zA-Z0-9] 范围可以连写 预定义类 预定义类 等价 含义 . [^\r\n] 除了回车和换行符之外的字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 \S [^\t\n\x0B\f\r] 非空白字符 \w [a-zA-Z0-9] 单词字符（字母，数字，下划线） \W [^a-zA-Z0-9] 非单词字符 1234str = 'ab1/';result = str.replace(/ab\d./, 'X'); // ab + 数字 + 除了\n的任意字符console.log(result); // X 边界 预定义类 含义 例子 ^ 以XXXX开始 ^a $ 以XXXX结束 a$ \b 单词边界 \ba\b \B 非单词边界 \Ba\B 123456789101112131415161718192021str = 'This is a dog.';result = str.replace(/is/g, '0'); //只要是is，就会被替换console.log(result); //Th0 0 a dog.result = str.replace(/\bis\b/g, '0'); //只有is为一个单独的单词，才会被替换console.log(result); //This 0 a dog.result = str.replace(/\Bis\b/g, '0'); //只有is前面不为单词开始，后面是单词结束。才会被替换console.log(result); //Th0 is a dog.str = '@123@456@789@';result = str.replace(/@./g, '0'); //替换“@+除了\n的任意字符”为“0”console.log(result); //023056089@result = str.replace(/^@./g, '0'); //替换“@+除了\n的任意字符”并且是字符串开头为“0”console.log(result); //023@456@789@result = str.replace(/.@$/g, '0'); //替换“除了\n的任意字符+@”并且是字符串结尾为“0”console.log(result); //@123@456@780 量词 预定义类 含义 ? 出现0次或者1次 + 出现1次或多次 * 出现0次或多次 {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现n次 {0,m} js不支持{,m},这里表示出现0次到m次 1234str = '123456789';result = str.replace(/\d*/, '0'); //将所有的数字都替换成0console.log(result); //0 贪婪模式和非贪婪模式在js中，正则表达式默认的就是贪婪模式，使用非贪婪模式就需要在量词的后面加上一个“?”。 /\d*?/ /\d{1,5}?/ /\d+?/ /\d??/ … 12345678910str = '123456789';result = str.replace(/\d*/, '0');console.log(result); //0result = str.replace(/\d&#123;3,6&#125;/, '0'); //贪婪模式，默认就是console.log(result); // 0789result = str.replace(/\d&#123;3,6&#125;?/, '0'); //非贪婪模式console.log(result); // 0456789 贪婪模式会尽可能的去匹配所有字符，非贪婪会尽可能少的来匹配。如上代码。 分组和或运算使用”( )”可以达到分组的功能。如下，使量词作用与分组。 (zachrey){3} 表明 zachrey应该出现三次zachrey(3) 表明 字符串最后的“y”应该出现三次 使用“|”可以达到或运算的效果 zachrey | zhang =&gt; 1.zachreyhang 2.zachrezhang(zachrey) | (zhang) =&gt; 1.zachrey 2.zhang 反向引用现有一个要求： 将时间 years-months-days 格式的时间装换为 months/days/years 格式，例如”2017-01-22” 装换为 “01/22/2017”,时间内容可能变化，但是格式固定。那么有这样的要求的时候，就需要使用反向引用来解决。在js正则表达式中有这样的字符样式 $1, $2, $3, $4…它们分别表示的是分组1、分组2、分组3、分组4…里面的内容。前提情况下，正则表达式里面有分组，没有的话，它们就会变为原义字符。1234str = "2017-01-22";result = str.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/, "$2/$3/$1"); // $2 第二个分组console.log(result); //01/22/2017 忽略分组如果不希望分组被$捕获，只需要在分组里面加上“?:”。 /(?:zachrey)(zhang)/ $1 =&gt;&gt;&gt; zhang 前瞻正则表达式从文本头部向尾部开始解析，那么现在的尾部被称为“前”，开始的头部称为“后”。前瞻就是在正则表达式匹配到规则的时候向前检查是否符合断言。后顾和前瞻的方向相反，js并不支持后顾。符合和不符合特定的断言称为肯定/正向匹配和否定/负向匹配。 正向前瞻： exp(?=assert)负向前瞻: exp(?!assert) 1234567str = 'a1b*c4';result = str.replace(/[a-z](?=\d)/g, 'X'); //替换字母并且该字母后面跟的是数字console.log(result); //X1b*X4result = str.replace(/[a-z](?!\d)/g, 'X'); //替换字母并且该字母后面跟的不是数字console.log(result); //a1X*c4 正则表达式对象的属性 global : 是否全文搜索，默认false ignore case : 是否大小写敏感，默认false multiline : 多行搜索模式，默认false lastindex : 是当前表达式匹配内容的最后一个字符的下一个字符的位置下标 source : 正则表达式的文本字符串 这些属性都是只读属性 常用方法 Regexp.prototype.test() Regexp.prototype.exec() String.prototype.search() String.prototype.match() String.prototype.replace() String.prototype.split()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+github创建个人博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo-github%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[准备工作 nodejs的安装 github账号 域名 最先，还是以官方的文档为最权威的说明：官方文档 首先，我们需要先保证电脑上安装了nodejs和git，过程中是需要用到git bash。 git nodejs 开始 现在是默认电脑已经安装好了以两个东西。 先自己在电脑中新建一个文件夹，至于哪个盘没有限制，高兴就好。不过还是建议能将文件归档分类，这是一个好习惯，以后找起来方便。 进入文件夹，在空白的位置右击鼠标，选择Git Bash Here，就会出现git的命令行工具，是一个小黑框。如果git没有安装好，那么右键菜单上面是没有这个选项的。那么现在我们在这个命令行工具上输入下面的命令：1$ npm install -g hexo-cli nodejs安装完成后，就会自带的安装npm，这个npm是nodejs包管理工具，这里就是用npm安装hexo客户端， -g意思是全局安装，以后随便哪个文件下都可以使用hexo。 接下来就是使用hexo来生产博客需要的文件。1$ hexo init 顺序执行之后，刚才的文件夹（我这里是Blog）里面多了很多文件。不要急，接下来继续执行一下命令12$ hexo g$ hexo s 出现的这样画面： 浏览器中出现的画面： 这样，本地的博客是能正常运行了。 Git的设置创建一个Repository建立与你用户关联的仓库，仓库的名字必须要为“your_name.github.io”,这是一个固定写法，这个写法只是在这里是特殊的，正常使用github仓库名字没必要这样。 接下来就需要修改hexo的配置文件，来将本地与github仓库远程关联上来。下图是目录结构，配置文件就在博客根目录（我这里是Blog文件夹）。名字为： _config.yml 在文件中搜索：deploy，将它设置为：(注意冒号后面有一个空格)1234deploy: type: git repo: https://github.com/your_name/your_name.github.io branch: master 然后安装部署工具：1$ npm install hexo-deployer-git --save 安装成功后，执行:1$ hexo deploy 或者：1$ hexo d 这时候hexo g命令生成在public文件夹下面的静态文件就会部署到github上你刚创建的仓库里面。 在浏览器上输入： “your_name.github.io”就会出现最开始在本地开启的博客页面。如果出现DNS未找到，或者网页错误，那么先等待片刻，过3~5分钟再试试。如果还出现错误，请仔细检查上面每一步操作，检查下nodejs，git的安装和配置，特别是git的设置。关于git的设置请参考:Git安装与配置 - 铁锚的CSDN博客 - 博客频道 - CSDN.NET 至此，如果我们每次发布新日志，一般的步骤为：12345hexo cleanhexo generatehexo deploy 域名解析下面以万网购买的域名为例。我是通过阿里云上的万网购买的域名，进入到阿里云的网页管理界面。先进入到万网的管理页面，找到域名解析栏目： 这里添加两个解析：（记录类型）CNAME， （主机记录）www和@，（记录值）your_name.github.io 很重要的一步： 在博客目录下的source文件夹内创建文件“CNAME”，名字一定不要写错，并且不能有后缀名，文件里面的内容为，你的域名。注意，不要书写www。现在执行：12$ hexo g $ hexo deploy 将新文件重新生成，然后再部署到github上。到这里，就可以尝试使用你的域名去访问新建立的博客了。域名解析时间一般在10分钟以内，如果访问出现404，就先等待5分钟左右，但一般都会立即生效。 如果还是404就仔细检查CNAME的内容，并跑到你的github仓库中看看有没有CNAME文件，并且里面的内容是否正确。因为hexo deploy如果没有正常执行的话，CNAME文件是部署不到github仓库上去的。这里就再三声明，如果github上没有，那就再检查你的git配置。 最后给大家推荐个主题Next Elegant Theme for Hexo 文档 这里有详细的使用说明。 具体博客的操作，更改请参考Hexo官网文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇日志]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[博客 一直想拥有一个属于自己的独立博客，最近在学习Python，又看了些微信公众号上推送的2017年程序员的生存之道，觉得是时候必须建立个博客了。所以在网上查找了写关于个人博客的创建方法，最后决定使用了Hexo这个博客框架。因为它正好是使用nodejs构成的，使用npm安装即可，之后再看官方文档和喜欢的主题（Next）的文档等，最终折腾了10个小时左右。功能并不多但是基本的都有了，以后会慢慢完善。最重要的是以这个博客来监督自己去完成一些事情。 过去的2016 这一年，5月之前一直在学习C++和Linux，当时这两个东西我是饶有兴趣。之后一直在做Hybrid移动设备的开发，至今很久没有去继续学习这两种东西，不过平时还是经常接触Linux。 现在的2017 熟悉掌握ECMAScript6 使用Python制作爬虫工具 Python 的 Web开发 Appcan4.0 nodejs]]></content>
      <categories>
        <category>Plans</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
</search>
