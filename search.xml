<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[移动前端开发深入理解]]></title>
      <url>%2F2017%2F03%2F13%2F%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-viewport-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一个网页在pc端和移动端能统一适配，关键因素就在于viewport。在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 一、viewport的概念viewport就是设备上用来显示网页的那一块区域，再具体一点就是，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。 二、css中的1px并不等于设备的1px 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。css样式里面的px和物理像素并不是相等的，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。 在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西。 三、viewport的三个理论 首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。 但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 再总结一下：把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 四、利用meta标签对viewport进行控制 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？ meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。 在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下： width: 设置layout viewport 的宽度，为一个正整数，或字符串”width-device” initial-scale: 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数 height: 设置layout viewport 的高度，这个属性对我们并不重要，很少使用 user-scalable: 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素。 target-densitydpi: 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用。 五、把当前的viewport宽度设置为 ideal viewport 的宽度要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。 这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。 这样的设置，也能达到相同的结果html1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。 因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？ 要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了 后是否能把当前的viewport宽度变成 ideal viewport 的宽度的测试结果。 测试结果表明 initial-scale=1 也能把当前的viewport宽度变成 ideal viewport 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。但这点小瑕疵已经无关紧要了。 但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？比如：html1&lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt; width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度） 最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 六、结语首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事。 第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 来得到一个理想的viewport（也就是前面说的ideal viewport）。 为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript作用域]]></title>
      <url>%2F2017%2F02%2F11%2Fjavascript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。 词法作用域考虑以下代码：12345678 function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 );&#125;foo( 2 ); // 2, 4, 12在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。 包含着整个全局作用域，其中只有一个标识符： foo 。 包含着 foo 所创建的作用域，其中有三个标识符： a 、 - bar 和 b 。 包含着 bar 所创建的作用域，其中只有一个标识符： c 。 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 JavaScript 中有两个机制可以“欺骗”词法作用域： eval(..) 和 with 。但一般不建议使用，这里不多做介绍。 函数作用域和块作用域JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，下面我们来看一下。 考虑下面的代码：123456789function foo(a) &#123; var b = 2; // 一些代码 function bar() &#123; // ... &#125; // 更多的代码 var c = 3;&#125; 在这个代码片段中， foo(..) 的作用域气泡中包含了标识符 a 、b 、 c 和 bar 。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标识符： foo 。由于标识符 a 、 b 、 c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的代码会导致 ReferenceError 错误： bar(); // 失败 console.log( a, b, c ); // 三个全都失败但是，这些标识符（ a 、 b 、 c 、 foo 和 bar ）在 foo(..) 的内部都是可以被访问的，同样在bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。 隐藏内部实现 对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。 实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。例如：123456789function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内容隐藏在 doSomething(..) 内部，例如：123456789function doSomething(a) &#123; function doSomethingElse(a) &#123; return a - 1; &#125; var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;doSomething( 2 ); // 15现在， b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。 函数作用域我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。1234567var a = 2;function foo() &#123; // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3&#125; // &lt;-- 以及这一行foo(); // &lt;-- 以及这一行console.log( a ); // 2 虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 foo() ，意味着 foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（ foo() ）调用这个函数才能运行其中的代码。如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。 幸好，JavaScript 提供了能够同时解决这两个问题的方案:123456var a = 2;( function foo()&#123; // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3&#125;)(); // &lt;-- 以及这一行console.log( a ); // 2(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 匿名和具名对于函数表达式最熟悉的场景可能就是回调参数了，比如：123setTimeout( function() &#123; console.log("I waited 1 second!");&#125;, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：123setTimeout( function timeoutHandler() &#123; // &lt;-- 快看，我有名字了！ console.log( "I waited 1 second!" );&#125;, 1000 ); 立即执行函数表达式123456var a = 2;(function foo() &#123; var a = 3; console.log( a ); // 3&#125;)();console.log( a ); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。 这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）； 函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。 相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式： (function(){ .. }()) 。仔细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。 这两种形式在功能上是一致的。选择哪个全凭个人喜好。 IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。例如：1234567var a = 2;(function IIFE( global ) &#123;var a = 3;console.log( a ); // 3console.log( global.a ); // 2&#125;)( window );console.log( a ); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global ，因此在代码风格上对全局 对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。 块作用域 除 JavaScript 外的很多编程语言都支持块作用域，因此其他语言的开发者对于相关的思维方式会很熟悉，但是对于主要使用 JavaScript 的开发者来说，这个概念会很陌生。 123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i ，通常是因为只想在 for 循环内部的上下文中用 i ，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。另外一个例子：123456var foo = true;if (foo) &#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125;bar 变量仅在 if 声明的上下文中使用，因此如果能将它声明在 if 块内部中会是一个很有意义的事情。但是，当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。 try/catch非常少有人会注意到 JavaScript 的 ES3 规范中规定 try / catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。1234567try &#123; undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123; console.log( err ); // 能够正常执行！&#125;console.log( err ); // ReferenceError: err not found let到目前为止，我们知道 JavaScript 在暴露块作用域的功能中有一些奇怪的行为。如果仅仅是这样，那么 JavaScript 开发者多年来也就不会将块作用域当作非常有用的机制来使用了。幸好，ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。1234567var foo = true;if (foo) &#123; let bar = foo * 2; bar = something( bar ); console.log( bar );&#125;console.log( bar ); // ReferenceError let 循环:一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。1234for (let i=0; i&lt;10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError下面通过另一种方式来说明每次迭代时进行重新绑定的行为：1234567&#123; let j; for (j=0; j&lt;10; j++) &#123; let i = j; // 每个迭代重新绑定！ console.log( i ); &#125;&#125; const除了 let 以外，ES6 还引入了 const ，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常 ! b = 4; // 错误 !&#125;console.log( a ); // 3console.log( b ); // ReferenceError! 小结 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。 从 ES3 开始， try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（ var 关键字的表亲），用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。 提升 到现在为止，已经很熟悉作用域的概念，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。但是作用域同其中的变量声明出现的位置有某种微妙的联系。 先有鸡还是先有蛋直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。考虑以下代码：123a = 2;var a;console.log( a );你认为 console.log(..) 声明会输出什么呢？很多人会认为是 undefined ，因为 var a 声明在 a = 2 之后，他们自然而然地认为变量被重新赋值了，因此会被赋予默认值 undefined 。但是，真正的输出结果是 2 。 编译器当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明： var a; 和 a =2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。我们的第一个代码片段会以如下形式进行处理：123var a;a = 2;console.log( a );因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。看着这样的代码：12345foo();function foo() &#123; console.log( a ); // undefined var a = 2;&#125;foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。变成这样：123456function foo() &#123; var a; console.log( a ); // undefined a = 2;&#125;foo();可以看到，函数声明会被提升，但是函数表达式却不会被提升。1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123;// ...&#125;; 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。12345678foo(); // 1var foo; function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;;会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;;注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。12345678910foo(); // 3function foo() &#123; console.log( 1 );&#125;var foo = function() &#123; console.log( 2 );&#125;;function foo() &#123; console.log( 3 );&#125; 小结 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 代码段来至于《你不知道的javascript》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年时光轴]]></title>
      <url>%2F2017%2F01%2F27%2F2016%E5%B9%B4%E6%97%B6%E5%85%89%E8%BD%B4%2F</url>
      <content type="text"><![CDATA[2016年时光轴 ２０１６年，在工作的充实下，时间好像过的更快。5月中旬，接触了APPCAN这种混合开发平台，当时几天培训和讲解，也是弄得一头雾水。没办法，当时听不懂，所以就恶补了下前端的基础知识，最后就能慢慢的动手了。当时一起考初级、中级认证是最激动的时候。不过好在有老师和几个伙伴的陪伴下，我们一起顺利的拿下了认证，也得到了公司初次合作的认可。 5月 第一个练手项目，第一次接触项目需求分析会议，听得非常认真，在为期20天左右的开发时间中，每天都会碰到问题并去解决问题，那时可能也把APPCAN的技术经理麻烦了一阵子吧。最终还是顺利完成，认识到了APPCAN这个平台的方便，也认识到了自己知识的不足。以微茫的知识，就能开发出一个Android和IOS都能跑的APP，此时，自己感到了一丝成就感，之后将APP上传到IOS的APP商店费了不少精力，查询的资料何其多，解决问题就应该坚持不懈，不断尝试。 6，7月 中间休息了一段时间，闲的时候，就加强练习下HTML+CSS+JS的知识体系，在此“慕课网”给我的帮助还是真不少，当然，这里面只能叫我入门的知识。更多的还是在网上的论坛、博客上看别人的解答。到此，JS的灵活激发了我一丝好奇心，希望把它能更好的掌握和设计。 学习了一段时间的JS，迎来了第二个项目。最开始，拿到了一种红外扫码的定制设备，相对来说比第一个项目的难度要大，前后台数据交互很多，好的是以前有一点后端服务的概念，知道数据交互的流程，能勉强按要求去完成，学会和后端人员沟通，并定制接口数据，是我在这个项目得到的最大的收获，虽然“大冶有色”也需要沟通，但是规模会比这个要小。 8,9月 第二个项目“长高条码管理系统”，时间较长，2个月左右，开发用了一个月，之后剩下的就是维护了。维护的期间就在学校和公司穿梭，因为没有什么很大的问题，所以那一段时间是很放松的。这个时候开始了培训第二批队员的计划，因此，走上了讲台。平时常在“慕课网”上面听各种老师授课，并且大二上学期做过半学期的C语言助教，单独讲授过几次课，算是有过点经验，但是第一次开始的时候，还是适应了一段时间。觉得还是要认真备课，因为临场敲击代码，真的很难做到正确和准确。 10,11,12月 10月开始，进行类似于“长高条码管理系统”的第三个项目，目前就进行到这里，一直都在增加和更改。着实忙了很大一段时间。最初说的是10月25交成功，所以不停的赶进度，最后这个时间无限的往后延迟，剩下的就是无尽的维护和更改。因为类似于之前的“长高条码管理系统”，在维护中产生了很大的厌倦情绪，在临近期末考试的时期尤为明显，伙伴们都产生了这种情绪，这也许就是初到“职场”的浮躁。时间的磨练，最后将这种情绪很好的沉淀下来了，现在公司闲暇的时候，看看技术文摘，大有精神的时候就学android或者NodeJS，在此期间还是用Python写了一个根据时间删除指定文件内容的小工具代码，最后使用，感觉没有想象中的好用；使用NodeJs和github等一些平台搭建了一个属于自己的博客，也算是年终很好的安慰了。 不足和需改进方面： 要充分利用在公司的闲余时间，学学英语也是好的。 项目初始设计的时候加强大局观，以便于维护、修改、扩展为前提，不能以前期方便为主。 文档记录具体、正规化。 处理很多事情时，必须划分重要等级，依次处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript正则表达式]]></title>
      <url>%2F2017%2F01%2F18%2Fjavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[javascript &amp; 正则表达式 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式并不是javascript所特有的，很多语言都支持正则，但是每种语言对正则表达式的支持或多或少会存在差别。 正则表达式在js中的存在形式在js中，我们可以使用RegExp和字面量来创建正则表达式的对象。RegExp对象：1var re = new RegExp('abc');字面量：1var re = /abc/;正则表达式有三种模式：（全局）global， （忽略大小写）ignoreCase， （多行搜索）multiLines开启的方式为：1var re = new RegExp('abc','igm');或者1var re = /abc/igm; i -&gt; 执行对大小写不敏感的匹配。 g -&gt; 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m -&gt; 执行多行匹配。 正则表达式组成形式 原义字符 ： 字符本身的意思 ，例如 a就是字母a 元字符 ：在正则表达式中有特殊含义的非字母字符，例如：* + ^ $ . | \ ( ) { } [ ] /a/ /a*/ /a+/ … 字符类一般情况下正则表达式里面的一个字符对应字符串中的一个字符。 /abc/ 对应字符串”abc”，不对应”abcd”和”ab”等。 使用”[ ]”元字符来构建一个类（类是一个泛指符合某些特征性对象，而不是特殊的指一个字符）。 /[abc]/ 指的可以匹配一个字符，这个字符必须是a,b,c三个中的其中一个。/[^abc]/ 可以匹配一个字符，这个字符必须不是a,b,c三个中的其中任何一个。 1234567str = 'a1b2c3d4';result = str.replace(/[abc]/g, 'X'); //匹配a,b,c三个中任何一个。 a or b or cconsole.log(result); //X1X2X3d4result = str.replace(/[^abc]/g, 'X'); //匹配不为a,b,c三个中任何一种。 !a and !b and !cconsole.log(result); //aXbXcXXX 范围类 [a-z] 可以匹配一个字符，改字符必须为a,b,c,d…z 中的一个[a-zA-Z0-9] 范围可以连写 预定义类 预定义类 等价 含义 . [^\r\n] 除了回车和换行符之外的字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 \S [^\t\n\x0B\f\r] 非空白字符 \w [a-zA-Z0-9] 单词字符（字母，数字，下划线） \W [^a-zA-Z0-9] 非单词字符 1234str = 'ab1/';result = str.replace(/ab\d./, 'X'); // ab + 数字 + 除了\n的任意字符console.log(result); // X 边界 预定义类 含义 例子 ^ 以XXXX开始 ^a $ 以XXXX结束 a$ \b 单词边界 \ba\b \B 非单词边界 \Ba\B 123456789101112131415161718192021str = 'This is a dog.';result = str.replace(/is/g, '0'); //只要是is，就会被替换console.log(result); //Th0 0 a dog.result = str.replace(/\bis\b/g, '0'); //只有is为一个单独的单词，才会被替换console.log(result); //This 0 a dog.result = str.replace(/\Bis\b/g, '0'); //只有is前面不为单词开始，后面是单词结束。才会被替换console.log(result); //Th0 is a dog.str = '@123@456@789@';result = str.replace(/@./g, '0'); //替换“@+除了\n的任意字符”为“0”console.log(result); //023056089@result = str.replace(/^@./g, '0'); //替换“@+除了\n的任意字符”并且是字符串开头为“0”console.log(result); //023@456@789@result = str.replace(/.@$/g, '0'); //替换“除了\n的任意字符+@”并且是字符串结尾为“0”console.log(result); //@123@456@780 量词 预定义类 含义 ? 出现0次或者1次 + 出现1次或多次 * 出现0次或多次 {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现n次 {0,m} js不支持{,m},这里表示出现0次到m次 1234str = '123456789';result = str.replace(/\d*/, '0'); //将所有的数字都替换成0console.log(result); //0 贪婪模式和非贪婪模式在js中，正则表达式默认的就是贪婪模式，使用非贪婪模式就需要在量词的后面加上一个“?”。 /\d*?/ /\d{1,5}?/ /\d+?/ /\d??/ … 12345678910str = '123456789';result = str.replace(/\d*/, '0');console.log(result); //0result = str.replace(/\d&#123;3,6&#125;/, '0'); //贪婪模式，默认就是console.log(result); // 0789result = str.replace(/\d&#123;3,6&#125;?/, '0'); //非贪婪模式console.log(result); // 0456789 贪婪模式会尽可能的去匹配所有字符，非贪婪会尽可能少的来匹配。如上代码。 分组和或运算使用”( )”可以达到分组的功能。如下，使量词作用与分组。 (zachrey){3} 表明 zachrey应该出现三次zachrey(3) 表明 字符串最后的“y”应该出现三次 使用“|”可以达到或运算的效果 zachrey | zhang =&gt; 1.zachreyhang 2.zachrezhang(zachrey) | (zhang) =&gt; 1.zachrey 2.zhang 反向引用现有一个要求： 将时间 years-months-days 格式的时间装换为 months/days/years 格式，例如”2017-01-22” 装换为 “01/22/2017”,时间内容可能变化，但是格式固定。那么有这样的要求的时候，就需要使用反向引用来解决。在js正则表达式中有这样的字符样式 $1, $2, $3, $4…它们分别表示的是分组1、分组2、分组3、分组4…里面的内容。前提情况下，正则表达式里面有分组，没有的话，它们就会变为原义字符。1234str = "2017-01-22";result = str.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/, "$2/$3/$1"); // $2 第二个分组console.log(result); //01/22/2017 忽略分组如果不希望分组被$捕获，只需要在分组里面加上“?:”。 /(?:zachrey)(zhang)/ $1 =&gt;&gt;&gt; zhang 前瞻正则表达式从文本头部向尾部开始解析，那么现在的尾部被称为“前”，开始的头部称为“后”。前瞻就是在正则表达式匹配到规则的时候向前检查是否符合断言。后顾和前瞻的方向相反，js并不支持后顾。符合和不符合特定的断言称为肯定/正向匹配和否定/负向匹配。 正向前瞻： exp(?=assert)负向前瞻: exp(?!assert) 1234567str = 'a1b*c4';result = str.replace(/[a-z](?=\d)/g, 'X'); //替换字母并且该字母后面跟的是数字console.log(result); //X1b*X4result = str.replace(/[a-z](?!\d)/g, 'X'); //替换字母并且该字母后面跟的不是数字console.log(result); //a1X*c4 正则表达式对象的属性 global : 是否全文搜索，默认false ignore case : 是否大小写敏感，默认false multiline : 多行搜索模式，默认false lastindex : 是当前表达式匹配内容的最后一个字符的下一个字符的位置下标 source : 正则表达式的文本字符串 这些属性都是只读属性 常用方法 Regexp.prototype.test() Regexp.prototype.exec() String.prototype.search() String.prototype.match() String.prototype.replace() String.prototype.split()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo+github创建个人博客]]></title>
      <url>%2F2017%2F01%2F12%2F%E4%BD%BF%E7%94%A8Hexo-github%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[准备工作 nodejs的安装 github账号 域名 最先，还是以官方的文档为最权威的说明：官方文档 首先，我们需要先保证电脑上安装了nodejs和git，过程中是需要用到git bash。 git nodejs 开始 现在是默认电脑已经安装好了以两个东西。 先自己在电脑中新建一个文件夹，至于哪个盘没有限制，高兴就好。不过还是建议能将文件归档分类，这是一个好习惯，以后找起来方便。 进入文件夹，在空白的位置右击鼠标，选择Git Bash Here，就会出现git的命令行工具，是一个小黑框。如果git没有安装好，那么右键菜单上面是没有这个选项的。那么现在我们在这个命令行工具上输入下面的命令：1$ npm install -g hexo-cli nodejs安装完成后，就会自带的安装npm，这个npm是nodejs包管理工具，这里就是用npm安装hexo客户端， -g意思是全局安装，以后随便哪个文件下都可以使用hexo。 接下来就是使用hexo来生产博客需要的文件。1$ hexo init 顺序执行之后，刚才的文件夹（我这里是Blog）里面多了很多文件。不要急，接下来继续执行一下命令12$ hexo g$ hexo s 出现的这样画面： 浏览器中出现的画面： 这样，本地的博客是能正常运行了。 Git的设置创建一个Repository建立与你用户关联的仓库，仓库的名字必须要为“your_name.github.io”,这是一个固定写法，这个写法只是在这里是特殊的，正常使用github仓库名字没必要这样。 接下来就需要修改hexo的配置文件，来将本地与github仓库远程关联上来。下图是目录结构，配置文件就在博客根目录（我这里是Blog文件夹）。名字为： _config.yml 在文件中搜索：deploy，将它设置为：(注意冒号后面有一个空格)1234deploy: type: git repo: https://github.com/your_name/your_name.github.io branch: master 然后安装部署工具：1$ npm install hexo-deployer-git --save 安装成功后，执行:1$ hexo deploy 或者：1$ hexo d 这时候hexo g命令生成在public文件夹下面的静态文件就会部署到github上你刚创建的仓库里面。 在浏览器上输入： “your_name.github.io”就会出现最开始在本地开启的博客页面。如果出现DNS未找到，或者网页错误，那么先等待片刻，过3~5分钟再试试。如果还出现错误，请仔细检查上面每一步操作，检查下nodejs，git的安装和配置，特别是git的设置。关于git的设置请参考:Git安装与配置 - 铁锚的CSDN博客 - 博客频道 - CSDN.NET 至此，如果我们每次发布新日志，一般的步骤为：12345hexo cleanhexo generatehexo deploy 域名解析下面以万网购买的域名为例。我是通过阿里云上的万网购买的域名，进入到阿里云的网页管理界面。先进入到万网的管理页面，找到域名解析栏目： 这里添加两个解析：（记录类型）CNAME， （主机记录）www和@，（记录值）your_name.github.io 很重要的一步： 在博客目录下的source文件夹内创建文件“CNAME”，名字一定不要写错，并且不能有后缀名，文件里面的内容为，你的域名。注意，不要书写www。现在执行：12$ hexo g $ hexo deploy 将新文件重新生成，然后再部署到github上。到这里，就可以尝试使用你的域名去访问新建立的博客了。域名解析时间一般在10分钟以内，如果访问出现404，就先等待5分钟左右，但一般都会立即生效。 如果还是404就仔细检查CNAME的内容，并跑到你的github仓库中看看有没有CNAME文件，并且里面的内容是否正确。因为hexo deploy如果没有正常执行的话，CNAME文件是部署不到github仓库上去的。这里就再三声明，如果github上没有，那就再检查你的git配置。 最后给大家推荐个主题Next Elegant Theme for Hexo 文档 这里有详细的使用说明。 具体博客的操作，更改请参考Hexo官网文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第一篇日志]]></title>
      <url>%2F2017%2F01%2F11%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[博客 一直想拥有一个属于自己的独立博客，最近在学习Python，又看了些微信公众号上推送的2017年程序员的生存之道，觉得是时候必须建立个博客了。所以在网上查找了写关于个人博客的创建方法，最后决定使用了Hexo这个博客框架。因为它正好是使用nodejs构成的，使用npm安装即可，之后再看官方文档和喜欢的主题（Next）的文档等，最终折腾了10个小时左右。功能并不多但是基本的都有了，以后会慢慢完善。最重要的是以这个博客来监督自己去完成一些事情。 过去的2016 这一年，5月之前一直在学习C++和Linux，当时这两个东西我是饶有兴趣。之后一直在做Hybrid移动设备的开发，至今很久没有去继续学习这两种东西，不过平时还是经常接触Linux。 现在的2017 熟悉掌握ECMAScript6 使用Python制作爬虫工具 Python 的 Web开发 Appcan4.0 nodejs]]></content>
    </entry>

    
  
  
</search>
